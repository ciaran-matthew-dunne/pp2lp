require open Logic.U.Set Logic.U.Prop Logic.U.Arrow;

// meta-level booleans
symbol bool : Set;
symbol Bool â‰” El bool;
// ?? rule El bool â†ª Prop;

symbol ite [a : Set] : El (bool â¤³ a â¤³ a â¤³ a);
symbol true  : Bool;
symbol false : Bool;

rule ite true $x _ â†ª $x
with ite false _ $y â†ª $y;


// boolean disjunction
sequential symbol <> : El (bool â¤³ bool â¤³ bool);
notation <> infix 5;
rule (true <> _)      â†ª true
with (_ <> true)      â†ª true
with (false <> false) â†ª false;

// boolean conjunction
sequential symbol && : El (bool â¤³ bool â¤³ bool);
notation && infix 5;
rule (true && true) â†ª true
with (false && _)   â†ª false
with (_ && false)   â†ª false;

// boolean negation
sequential symbol !! : El (bool â¤³ bool);
rule (!! true) â†ª false
with (!! false) â†ª true;

// ------- lists ------------------------------------------
injective symbol ğ•ƒ : Set â†’ TYPE;
injective symbol list : Set â†’ Set;
rule El (list $X) â†ª ğ•ƒ $X;

injective symbol nil [a : Set] : ğ•ƒ a;
injective symbol cons [a : Set] : El a â†’ ğ•ƒ a â†’ ğ•ƒ a;

symbol âˆ· [a] â‰” cons [a];
notation âˆ· infix right 10;

sequential symbol concat [a : Set] : El (list a â¤³ list a â¤³ list a);
rule concat nil $ys â†ª $ys
with concat (cons $x $xs) $ys â†ª cons $x (concat $xs $ys);

sequential symbol elem [a : Set] : El (a â¤³ list a â¤³ bool);
rule (elem _   nil)         â†ª false
with (elem $x (cons $x _))  â†ª true
with (elem $x (cons _ $ys)) â†ª (elem $x $ys);

//sequential symbol reverse [a : Set] : El (list a â¤³ list a);
//rule (reverse nil)  â†ª nil
//with (reverse (cons $y $ys)) â†ª concat (reverse $ys) ($y) ;

symbol â‹¿ [a : Set] â‰” elem [a];
notation â‹¿ infix 0;

// `foreach p xs` rewrites to `true` iff `p` holds for each `x` in `xs`.
sequential symbol foreach [a : Set] :
  El ((a â¤³ bool) â¤³ list a â¤³ bool);
rule foreach $P nil â†ª true;
rule foreach $P (cons $x $xs) â†ª ($P $x) && foreach $P $xs;


// `replace x y zs` replaces the first instance of `x` in `xs` with `y`.
sequential symbol replace [a : Set] :
  El (a â¤³ a â¤³ list a â¤³ list a);

rule (replace  _ $y nil)             â†ª nil
with (replace $x $y (cons $x $zs))   â†ª cons $y $zs
with (replace $x $y (cons $z $zs))   â†ª cons $z (replace $x $y $zs);


// `nub xs` removes duplicate elements from `xs`.
symbol nub [a : Set] : El (list a â¤³ list a);
rule nub nil â†ª nil
with nub (cons $x $xs) â†ª
  ite ($x â‹¿ $xs)
    (nub $xs)
    (cons $x (nub $xs));

// `union xs ys` returns the (set-theoretic) union of `xs` and `ys`.
symbol union [a : Set] (xs ys : El (list a)) â‰”
  concat (nub xs) (nub ys);


// ----- product types experiment ------------
injective symbol â„¿ : Set â†’ Set â†’ TYPE;
symbol fst [X Y : Set] : (â„¿ X Y) â†’ El X;
symbol snd [X Y : Set] : (â„¿ X Y) â†’ El Y;

symbol Ã— : Set â†’ Set â†’ Set;
notation Ã— infix 20;

rule El ($X Ã— $Y) â†ª â„¿ $X $Y;
