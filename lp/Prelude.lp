require open Logic.U.Set Logic.U.Arrow;

// meta-level booleans. used for 'computational' side conditions.
symbol bool : Set;
symbol true  : El bool;
symbol false : El bool;

// boolean conditional operator.
symbol ite [a : Set] : El (bool â¤³ a â¤³ a â¤³ a);
rule ite true $x _ â†ª $x
with ite false _ $y â†ª $y;

// boolean disjunction
sequential symbol <> : El (bool â¤³ bool â¤³ bool);
notation <> infix 5;
rule (true <> _)      â†ª true
with (_ <> true)      â†ª true
with (false <> false) â†ª false;

// boolean conjunction
sequential symbol && : El (bool â¤³ bool â¤³ bool);
notation && infix 5;
rule (true && true) â†ª true
with (false && _)   â†ª false
with (_ && false)   â†ª false;

// boolean negation
sequential symbol !! : El (bool â¤³ bool);
rule (!! true) â†ª false
with (!! false) â†ª true;

// ------- lists ------------------------------------------
// primitive type constructor for lists.
injective symbol ğ•ƒ : Set â†’ TYPE;

// set-code for lists.
injective symbol list : Set â†’ Set;
rule El (list $X) â†ª ğ•ƒ $X;

// primitive data constructors for lists.
injective symbol nil [a : Set] : ğ•ƒ a;
injective symbol cons [a : Set] : El a â†’ ğ•ƒ a â†’ ğ•ƒ a;

// infix notation for `cons`.
symbol âˆ· [a] â‰” cons [a];
notation âˆ· infix right 10;

// `elem x xs â‰¡ true` iff `x` is an element of `xs`.
sequential symbol elem [a : Set] : El (a â¤³ list a â¤³ bool);
rule (elem _   nil)         â†ª false
with (elem $x (cons $x _))  â†ª true
with (elem $x (cons _ $ys)) â†ª (elem $x $ys);

// infix notation for `elem`.
symbol â‹¿ [a : Set] â‰” elem [a];
notation â‹¿ infix 0;

// list concatenation
sequential symbol concat [a : Set] : El (list a â¤³ list a â¤³ list a);
rule concat nil $ys â†ª $ys
with concat (cons $x $xs) $ys â†ª cons $x (concat $xs $ys);

// `foreach p xs â‰¡ true` iff `p x â‰¡ true` for each `x` in `xs`.
sequential symbol foreach [a : Set] :
  El ((a â¤³ bool) â¤³ list a â¤³ bool);
rule foreach $P nil â†ª true;
rule foreach $P (cons $x $xs) â†ª ($P $x) && foreach $P $xs;

// `replace x y zs` replaces the first instance of `x` in `xs` with `y`.
sequential symbol replace [a : Set] :
  El (a â¤³ a â¤³ list a â¤³ list a);
rule (replace  _ $y nil)             â†ª nil
with (replace $x $y (cons $x $zs))   â†ª cons $y $zs
with (replace $x $y (cons $z $zs))   â†ª cons $z (replace $x $y $zs);

// DEPRECATED!
// `nub xs` removes duplicate elements from `xs`.
symbol nub [a : Set] : El (list a â¤³ list a);
rule nub nil â†ª nil
with nub (cons $x $xs) â†ª
  ite ($x â‹¿ $xs)
    (nub $xs)
    (cons $x (nub $xs));

// DEPRECATED!
// `union xs ys` returns the (set-theoretic) union of `xs` and `ys`.
symbol union [a : Set] (xs ys : El (list a)) â‰”
  concat (nub xs) (nub ys);

// DEPRECATED!
// primitive type constructor for cartesian product.
injective symbol â„¿ : Set â†’ Set â†’ TYPE;
symbol fst [X Y : Set] : (â„¿ X Y) â†’ El X;
symbol snd [X Y : Set] : (â„¿ X Y) â†’ El Y;

// infix set-code constructor for cartesian product.
symbol Ã— : Set â†’ Set â†’ Set;
notation Ã— infix 20;
rule El ($X Ã— $Y) â†ª â„¿ $X $Y;
