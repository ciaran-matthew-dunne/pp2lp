require open pp2lp.Prelude;

// ------ predicates, expressions, formulas ------
symbol ð•Š : TYPE;      // define type for strings,
builtin "String" â‰” ð•Š; // bind string literals to this type.

symbol str : Set;     // called `idt` in the PP docs.
rule El str â†ª ð•Š;      //


// set-codes for basic syntactic categories.
symbol vrb : Set â‰” list str; // "variable binding"
symbol prd : Set; // "predicate"
symbol exp : Set; // "expression"
symbol idv : Set; // "individual" - special type we use for "constants".

assert [a : Set] âŠ¢ a : Set;

// 'lift' an expression to a predicate.
injective symbol Î¨ : El exp â†’ El prd;
coerce_rule coerce (El exp) (El prd) $p â†ª Î¨ $p;

// 'lift' an individual to an expression.
injective symbol Î¹ : El idv â†’ El exp;
coerce_rule coerce (El idv) (El exp) $x â†ª Î¹ $x;
coerce_rule coerce (El idv) (El prd) $x â†ª Î¨ (Î¹ $x);

// ----- primitive logical symbols --------------
// basic logical connectives.
injective symbol VRAI : El prd;
injective symbol FAUX : El prd;
injective symbol and  : El (prd â¤³ prd â¤³ prd);
injective symbol or   : El (prd â¤³ prd â¤³ prd);
injective symbol =>   : El (prd â¤³ prd â¤³ prd);


injective symbol <=>  : El (prd â¤³ prd â¤³ prd);
injective symbol not  : El (prd â¤³ prd);
injective symbol =    : El (exp â¤³ exp â¤³ prd);

notation =   infix left 2;
notation and infix left 2;
notation or  infix left 2;
notation =>  infix left 2;
notation <=> infix left 1;
notation not prefix 3;

// quantifiers. explicit variable lists! not HOAS!
injective symbol ! : El vrb â†’ El prd â†’ El prd; // aka. âˆ€
injective symbol # : El (vrb â¤³ prd â¤³ prd);    // aka. âˆƒ
injective symbol â™¢ : El (vrb â¤³ prd â¤³ prd);   // aka. forall
injective symbol â™¡ : El (vrb â¤³ prd â¤³ prd);   // aka. forall2

// hacky notation for building string lists (e.g., for variable bindings).
symbol â‹… : El (str â¤³ list str)        â‰” Î» x, cons x nil;            // length 1
symbol â¨¾ : El (str â¤³ str â¤³ list str) â‰” Î» x y, cons x (cons y nil); // length 2

notation â‹… postfix 10;
notation â¨¾ infix right 5;

// set-theoretic membership.
injective symbol âˆˆ : El (exp â¤³ exp â¤³ prd);
notation âˆˆ infix left 2;

// set-theoretic equality. used only by `EQS1` and `EQS2`.
symbol eql_set : El (exp â¤³ exp â¤³ prd);

// ----- expressions -------------------------

// infix constructor for ordered pairs
symbol âˆ¥ : El (exp â¤³ exp â¤³ exp);
notation âˆ¥ infix left 5;

// cast strings to expressions.
injective symbol var : El (str â¤³ exp);
coerce_rule coerce ð•Š (El exp) $str â†ª var $str;

// helper function for `vars`.
sequential symbol vars_aux : El (exp â¤³ vrb â¤³ exp);
rule vars_aux $e nil           â†ª $e
with vars_aux $e (cons $y $ys) â†ª vars_aux ($e âˆ¥ var $y) $ys ;

// convert variable list to an expression.
symbol vars : El (vrb â¤³ exp);
rule vars (cons $x $xs) â†ª vars_aux (var $x) $xs;

// set-theoretic function/predicate application.
injective symbol â€µ : El (exp â¤³ exp â¤³ exp);
notation â€µ infix left 10;

// symbols for arithmetic.
injective symbol > : El (exp â¤³ exp â¤³ prd);
injective symbol â‰¤ : El (exp â¤³ exp â¤³ prd);
injective symbol < : El (exp â¤³ exp â¤³ prd);
injective symbol â‰ª : El (exp â¤³ exp â¤³ prd);
injective symbol ðŸŽ : El (exp);
injective symbol ðŸ : El (exp);
injective symbol â¨ª : El (exp â¤³ exp);
injective symbol + : El (exp â¤³ exp â¤³ exp);
injective symbol - : El (exp â¤³ exp â¤³ exp);

notation > infix 5;
notation â‰¤ infix 5;
notation < infix 5;
notation â‰ª infix 5;
notation + infix 5;
notation - infix 5;

// evaluation of 'atomic' arithmetic expressions.
symbol ev [a : Set] : El (a â¤³ bool);

// mysterious 'solveur' operation.
// only meaningful when `a â‰¡ exp` or `a â‰¡ prd`.
// ?? symbolic reduction of predicates/expressions with computable arithmetic ??
symbol solveur [a : Set] : El (a â¤³ a);
rule solveur (Î¨ $e) â†ª Î¨ (solveur $e);
rule solveur (Î¹ $p) â†ª (Î¹ $p);

// ----- Operations on terms -----------------------
// syntactic equality on expressions and predicates.
sequential symbol == [a : Set] : El (a â¤³ a â¤³ bool);
notation == infix 5;

// syntactic equality on `str`.
rule ((==) [str] $x $x) â†ª true
with ((==) [str] _  _)  â†ª false;

// syntactic equality on `prd`.
rule FAUX == FAUX â†ª true
with VRAI == VRAI â†ª true
with (not $p) == (not $q)           â†ª ($p == $q)
with ($p1 and $p2) == ($q1 and $q2) â†ª ($p1 == $q1) && ($p2 == $q2)
with ($p1 or $p2) == ($q1 or $q2)   â†ª ($p1 == $q1) && ($p2 == $q2)
with ($p1 => $p2) == ($q1 => $q2)   â†ª ($p1 == $q1) && ($p2 == $q2)
with ($p1 <=> $p2) == ($q1 <=> $q2) â†ª ($p1 == $q1) && ($p2 == $q2)
with ($e1 = $e2) == ($f1 = $f2)     â†ª ($e1 == $f1) && ($e2 == $f2)
with (Î¨ $e1) == (Î¨ $e2)             â†ª $e1 == $e2;
//with (! $P) == (! $Q) â†ª (`âˆ€ x, ($P x == $Q x))
//with (# $P) == (# $Q) â†ª (`âˆ€ x, ($P x == $Q x))
//with (â™¢ $P) == (â™¢ $Q) â†ª (`âˆ€ x, ($P x == $Q x))
//with (â™¡ $P) == (â™¡ $Q) â†ª (`âˆ€ x, ($P x == $Q x`));

// syntactic equality on `exp`.
rule (var $x == var $y) â†ª ($x == $y)
with ($e1 â€µ $e2) == ($f1 â€µ $f2) â†ª ($e1 == $f1) && ($e2 == $f2)
with (Î¹ $p) == (Î¹ $p) â†ª true;

// otherwise, return false.
rule _ == _ â†ª false;

symbol !== [a : Set] : El (a â¤³ a â¤³ bool)
  â‰” Î» x y, !! (x == y);
notation !== infix 5;

// ------- free variables ----------------
// when `t : exp` or `t : prd`,
//  `free x t â‰¡ true` if `x` occurs free in `t`.
sequential symbol free [a : Set] : El (str â¤³ a â¤³ bool);

// define `free x` on `prd`.
rule free $x ($P and $Q)  â†ª (free $x $P) <> (free $x $Q)
with free $x ($P or $Q)   â†ª (free $x $P) <> (free $x $Q)
with free $x ($P => $Q)   â†ª (free $x $P) <> (free $x $Q)
with free $x ($P <=> $Q)  â†ª (free $x $P) <> (free $x $Q)
with free $x (not $P)     â†ª free $x $P
with free $x (! $vs $P)   â†ª (free $x $P) && !! ($x â‹¿ $vs)
with free $x (# $vs $P)   â†ª (free $x $P) && !! ($x â‹¿ $vs)
with free $x ($e1 = $e2)  â†ª (free $x $e1) <> (free $x $e2)
with free $x FAUX â†ª false
with free $x VRAI â†ª false
with free $x (Î¨ $e) â†ª (free $x $e)
with free $x ($e1 âˆˆ $e2) â†ª (free $x $e1) <> (free $x $e2);

// define `free x` on `exp`.
rule free $x (var $y) â†ª ($x == $y)
with free $x (Î¹ _)    â†ª false
with free $x ($e1 â€µ $e2) â†ª (free $x $e1) <> (free $x $e2)
with free $x ($e1 âˆ¥ $e2) â†ª (free $x $e1) <> (free $x $e2);

// ------- free variables ----------------
// if `t : exp` or `t : prd`, then `subst x e t` is the result of rewriting
// all free occurrences of `x` in `t` with `e`.
sequential symbol subst [a : Set] : El (str â¤³ exp â¤³ a â¤³ a);

// define `subst x e` on `prd`.
rule subst $x $t ($P and $Q)  â†ª (subst $x $t $P) and (subst $x $t $Q)
with subst $x $t ($P or $Q)   â†ª (subst $x $t $P) or (subst $x $t $Q)
with subst $x $t ($P => $Q)   â†ª (subst $x $t $P) => (subst $x $t $Q)
with subst $x $t ($P <=> $Q)  â†ª (subst $x $t $P) <=> (subst $x $t $Q)
with subst $x $t (not $P)     â†ª not (subst $x $t $P)
with subst $x $t (! $vs $P)   â†ª ite ($x â‹¿ $vs) (! $vs $P) (! $vs (subst $x $t $P))
with subst $x $t (# $vs $P)   â†ª ite ($x â‹¿ $vs) (# $vs $P) (# $vs (subst $x $t $P))
with subst $x $t ($e1 = $e2)  â†ª (subst $x $t $e1) = (subst $x $t $e2)
with subst $x $t (Î¨ $p)       â†ª Î¨ (subst $x $t $p);

// define `subst x e` on `exp`.
rule subst $x $t (var $y) â†ª ite ($x == $y) $t (var $y)
with subst $x $t ($f â€µ $y) â†ª (subst $x $t $f) â€µ (subst $x $t $y);

// ------- operations exclusively for AND5 ---------------------------

// check if a predicate appears in an n-ary conjunction.
sequential symbol elem_conj : El (prd â¤³ prd â¤³ bool);
rule elem_conj $P ($P and $xs) â†ª true
with elem_conj $P ($Q and $xs) â†ª elem_conj $P $xs
with elem_conj $P _            â†ª false;

// replace a conjunct in an n-ary conjunction.
sequential symbol repl_conj : El (prd â¤³ prd â¤³ prd â¤³ prd);
rule repl_conj $Q $Q' ($Q and $xs) â†ª ($Q' and $xs)
with repl_conj $Q $Q' ($P and $xs) â†ª ($P  and (repl_conj $Q $Q' $xs))
with repl_conj _  _   $R           â†ª $R;
