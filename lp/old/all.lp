::::::::::::::
Prelude.lp
::::::::::::::
require open Logic.U.Set Logic.U.Prop Logic.U.Arrow;

// meta-level booleans
symbol bool : Set;
rule El bool â†ª Prop;

// lists
injective symbol list : Set â†’ Set;
symbol nil [a : Set] : El (list a);
symbol âˆ· [a : Set] : El (a â¤³ list a â¤³ list a);
notation âˆ· infix right 5;

sequential symbol elem [a : Set] : El (a â¤³ list a â¤³ bool);
rule (elem _   nil)       â†ª âŠ¥
with (elem $x ($x âˆ· _))   â†ª âŠ¤
with (elem $x (_  âˆ· $ys)) â†ª (elem $x $ys);

// `replace x y zs` replaces the first instance of `x` in `xs` with `y`.
sequential symbol replace [a : Set] : El (a â¤³ a â¤³ list a â¤³ list a);
rule (replace  _ $y nil)          â†ª nil
with (replace $x $y ($x âˆ· $zs))   â†ª $y âˆ· $zs
with (replace $x $y ($z âˆ· $zs))   â†ª $z âˆ· (replace $x $y $zs);

symbol â‰ˆ [a : Set] : El (a â¤³ a â¤³ bool);
notation â‰ˆ infix right 5;

// identifiers
symbol String : TYPE;
builtin "String" â‰” String;

symbol str : Set;
rule El str â†ª String;
symbol vrb : Set â‰” list str;

// proof of top
symbol TOP : Prf (âŠ¤) â‰”
  begin
    simplify;
    assume r h;
    refine h;
  end;
::::::::::::::
Rules.lp
::::::::::::::
require open Logic.U.Set Logic.U.Prop Logic.U.Arrow Logic.U.Inf;
require open pp2lp.Prelude pp2lp.Syntax;

// ----------------------------------------------
// 5.1. Conjunction
// ----------------------------------------------
symbol AND1 [H : El (list prd)] [P Q R : El prd] :
  âŸ (H âŸ not Q => R) â†’
  âŸ (H âŸ not P => R) â†’
  âŸ (H âŸ not (P and Q) => R);

symbol AND2 [H : El (list prd)] [P Q : El prd] :
  âŸ (H âŸ P => not Q) â†’
  âŸ (H âŸ not (P and Q));

symbol AND3 [H : El (list prd)] [P Q R : El prd] :
  âŸ (H âŸ P => (Q => R)) â†’
  âŸ (H âŸ (P and Q) => R);

symbol AND4 [H : El (list prd)] [P Q : El prd] :
  âŸ (H âŸ Q) â†’
  âŸ (H âŸ P) â†’
  âŸ (H âŸ (P and Q));

symbol AND5 [H : El (list prd)] [P' R A B : El prd] :
  Prf (elem A (to_list P')) â†’
  âŸ (H âŸ conj (replace (A => B) B (to_list P')) => R) â†’
  âŸ (H âŸ P' => R);


// ----------------------------------------------
// 5.2. Disjunction
// ----------------------------------------------
symbol OR1 [H : El (list prd)] [P Q R : El prd] :
  âŸ (H âŸ not P => (not Q => R)) â†’
  âŸ (H âŸ not (P or Q) => R);

symbol OR2 [H : El (list prd)] [P Q : El prd] :
  âŸ (H âŸ not Q) â†’
  âŸ (H âŸ not P) â†’
  âŸ (H âŸ not (P or Q));

symbol OR3 [H : El (list prd)] [P Q R : El prd] :
  âŸ (H âŸ Q => R) â†’
  âŸ (H âŸ P => R) â†’
  âŸ (H âŸ (P or Q) => R);

symbol OR4 [H : El (list prd)] [P Q : El prd] :
  âŸ (H âŸ not P => Q) â†’
  âŸ (H âŸ (P or Q));


// ----------------------------------------------
// 5.3. Implication
// ----------------------------------------------
symbol IMP1 [H : El (list prd)] [P Q R : El prd] :
  âŸ (H âŸ P => (not Q => R)) â†’
  âŸ (H âŸ not (P => Q) => R);

symbol IMP2 [H : El (list prd)] [P Q : El prd] :
  âŸ (H âŸ not Q) â†’
  âŸ (H âŸ P) â†’ // This is "H âŠ¢ P" in the antecedent
  âŸ (H âŸ not (P => Q));

symbol IMP3 [H : El (list prd)] [P Q R : El prd] :
  âŸ (H âŸ Q => R) â†’
  âŸ (H âŸ not(P) => R) â†’
  âŸ (H âŸ (P => Q) => R);

symbol IMP4 [H : El (list prd)] [P Q : El prd] :
  âŸ (P âˆ· H âŸ Q) â†’
  âŸ (H âŸ P => Q);

symbol IMP5 [H : El (list prd)] [P Q : El prd] :
  Prf (elem P H) â†’ // Side condition: "P est dans H"
  âŸ (H âŸ Q) â†’
  âŸ (H âŸ P => Q);

symbol IMP4' [H : El (list prd)] [P Q R S : El prd] :
  Prf ((P âˆ· H âŸ Q) âŸ¿ R) â†’
  Prf ((H âŸ P => Q) âŸ¿ (P => R));



// ----------------------------------------------
// 5.4. Equivalence
// ----------------------------------------------
symbol EQV1 [H : El (list prd)] [P Q R : El prd] :
  âŸ (H âŸ P => (not Q => R)) â†’
  âŸ (H âŸ not P => (Q => R)) â†’
  âŸ (H âŸ not (P <=> Q) => R);

symbol EQV2 [H : El (list prd)] [P Q : El prd] :
  âŸ (H âŸ P => not Q) â†’
  âŸ (H âŸ not Q => P) â†’
  âŸ (H âŸ not (P <=> Q));

symbol EQV3 [H : El (list prd)] [P Q R : El prd] :
  âŸ (H âŸ P => (Q => R)) â†’
  âŸ (H âŸ not P => (not Q => R)) â†’
  âŸ (H âŸ (P <=> Q) => R);

symbol EQV4 [H : El (list prd)] [P Q : El prd] :
  âŸ (H âŸ P => Q) â†’
  âŸ (H âŸ Q => P) â†’
  âŸ (H âŸ (P <=> Q));


// ----------------------------------------------
// 5.5. Negation
// ----------------------------------------------
symbol NOT1 [H : El (list prd)] [P R : El prd] :
  âŸ (H âŸ P => R) â†’
  âŸ (H âŸ not not P => R);

symbol NOT2 [H : El (list prd)] [P : El prd] :
  âŸ (H âŸ P) â†’
  âŸ (H âŸ not not P);


// ----------------------------------------------
// 5.6. Axioms
// ----------------------------------------------
symbol AXM1 [H : El (list prd)] [P Q : El prd] :
  Prf (elem (not P) H) â†’
  âŸ (H âŸ P => Q);

symbol AXM2 [H : El (list prd)] [P Q : El prd] :
  Prf (elem P H) â†’
  âŸ (H âŸ not P => Q);

symbol AXM3 [H : El (list prd)] [P : El prd] :
  Prf (elem P H) â†’
  âŸ (H âŸ P);

symbol AXM4 [H : El (list prd)] [P R : El prd] :
  Prf (elem R H) â†’
  âŸ (H âŸ P => R);

symbol AXM5 [H : El (list prd)] [P Q R : El prd] :
  Prf (elem (not Q) H) â†’
  âŸ (H âŸ P => (Q => R));

symbol AXM6 [H : El (list prd)] [P Q R : El prd] :
  Prf (elem Q H) â†’
  âŸ (H âŸ P => (not Q => R));

symbol AXM7 [H : El (list prd)] [P : El prd] :
  âŸ (H âŸ P => P);

symbol AXM8 [H : El (list prd)] [P' R : El prd] :
  Prf (elem R (to_list P')) â†’
  âŸ (H âŸ P' => R);

symbol AXM9 [H : El (list prd)] [R Q : El prd] [P : El (exp â¤³ prd)] [x E : El exp] :
  Prf (elem (`! x, not (VRAI and P x)) H) â†’
  Prf (P E â‰ˆ R) â†’
  âŸ (H âŸ R => Q);


// ----------------------------------------------
// 5.7. Universal quantification
// ----------------------------------------------
symbol ALL1 [H : El (list prd)] [P : El (exp â¤³ exp â¤³ prd)] [R : El prd] :
  âŸ (H âŸ (not (`! x, `! y, P x y)) => R) â†’
  âŸ (H âŸ (not (`! x, `! y, P x y)) => R);

symbol ALL2 [H : El (list prd)] [P : El (exp â¤³ exp â¤³ prd)] :
  âŸ (H âŸ not (`! x, `! y, P x y)) â†’
  âŸ (H âŸ not (`! x, `! y, P x y));

symbol ALL3 [H : El (list prd)] [P R : El prd] :
  âŸ (H âŸ (`! x, `! y, P) => R) â†’
  âŸ (H âŸ (`! x, `! y, P) => R);

symbol ALL4 [x y : El str] [H : El (list prd)] [P : El prd] :
  âŸ (H âŸ `! x, `! y, P) â†’
  âŸ (H âŸ `! x, `! y, P);

symbol ALL5 [H : El (list prd)] [P : El (exp â¤³ prd)] [R : El prd] :
  âŸ (H âŸ `! x, (not (P x) => R)) â†’
  âŸ (H âŸ not (`! x, P x) => R);

symbol ALL6 [H : El (list prd)] [P : El (exp â¤³ prd)] :
  âŸ (H âŸ ! P => FAUX) â†’
  âŸ (H âŸ not (! P));

symbol ALL7 [H : El (list prd)] [P R : El (exp â¤³ prd)] [Q : El prd] :
  (Î  x, Prf ((H âŸ P x) âŸ¿ R x)) â†’
  âŸ (H âŸ (`â™¢ x, R x) => Q) â†’
  âŸ (H âŸ (`! x, P x) => Q);

symbol ALL8 [H : El (list prd)] [P : El (exp â¤³ prd)] :
  (Î  x, âŸ (H âŸ P x)) â†’
  âŸ (H âŸ ! P);

symbol ALL9 [H : El (list prd)] [T : El (exp â¤³ prd)] [Q : El prd] :
  âŸ ((! T) âˆ· H âŸ Q) â†’
  âŸ (H âŸ â™¡ T => Q) ;

symbol ALL7' [H : El (list prd)] [P Q R S : El prd] :
  Prf ((H âŸ P) âŸ¿ R) â†’
  Prf ((H âŸ (`â™¢ x, R) => Q) âŸ¿ S) â†’
  Prf ((H âŸ (`! x, P) => Q) âŸ¿ S);

symbol ALL8' [H : El (list prd)] [P Q : El prd] :
  Prf ((H âŸ P) âŸ¿ Q) â†’
  Prf ((H âŸ (`! x, P)) âŸ¿ (`! x, Q));

symbol ALL9' [H : El (list prd)] [P : El (exp â¤³ prd)] [Q R : El prd] :
  Prf (((! P) âˆ· H âŸ Q) âŸ¿ R) â†’
  Prf ((H âŸ (â™¡ P) => Q) âŸ¿ (! P) => R);

// (??) redunant rules due to HOAS
symbol ALL5_1 [H : El (list prd)] [P R : El prd] : TYPE;
symbol ALL7_1 [H : El (list prd)] [P Q R S A : El prd] : TYPE;
symbol ALL7'_1 [H : El (list prd)] [P Q R S A : El prd] : TYPE;
symbol ALL8'_1 [H : El (list prd)] [P Q : El prd] : TYPE;

// ----------------------------------------------
// 5.8. Existential quantification
// ----------------------------------------------

symbol XST1 [x y : El str] [H : El (list prd)] [P R : El prd] :
  âŸ (H âŸ not (`# x, `# y, P) => R) â†’
  âŸ (H âŸ not (`# x, `# y, P) => R);

symbol XST2 [x y : El str] [H : El (list prd)] [P : El prd] :
  âŸ (H âŸ not (`# x, `# y, P) ) â†’
  âŸ (H âŸ not (`# x, `# y, P));

symbol XST3 [x y : El str] [H : El (list prd)] [P R : El prd] :
  âŸ (H âŸ (`# x, `# y, P) => R ) â†’
  âŸ (H âŸ (`# x, `# y, P) => R );

symbol XST4 [x y : El str] [H : El (list prd)] [P : El prd] :
  âŸ (H âŸ `# x, `# y, P) â†’
  âŸ (H âŸ `# x, `# y, P);

symbol XST5 [x : El str] [H : El (list prd)] [P R : El prd] :
  âŸ (H âŸ (`! x, not P) => R) â†’
  âŸ (H âŸ not (`# x, P) => R);

symbol XST5_1 [x : El str] [H : El (list prd)] [P R : El prd] :
  âŸ (H âŸ (`! x, P) => R) â†’
  âŸ (H âŸ not (`# x, not P) => R);

symbol XST6 [x : El str] [H : El (list prd)] [P : El prd] :
  âŸ (H âŸ `! x, not P) â†’
  âŸ (H âŸ not (`# x, P));

symbol XST6_1 [x : El str] [H : El (list prd)] [P : El prd] :
  âŸ (H âŸ `! x, P) â†’
  âŸ (H âŸ not (`# x, not P));

symbol XST7 [x : El str] [H : El (list prd)] [P R Q : El prd] :
  âŸ (H âŸ `! x, (P => R)) â†’
  âŸ (H âŸ (`# x, P) => R);

symbol XST8 [x y : El str] [H : El (list prd)] [P R A : El prd] :
  Prf ((H âŸ not P) âŸ¿ R) â†’
  âŸ (H âŸ (`! x, R) => VRAI) â†’
  âŸ (H âŸ (`# x, P));

// redunant rules.
symbol XST7_1 [x : El str] [H : El (list prd)] [P R Q : El prd] : TYPE;
symbol XST8_1 [x y : El str] [H : El (list prd)] [P R A : El prd] : TYPE;

// ----------------------------------------------
// 5.9. Vrai et Faux
// ----------------------------------------------
symbol VR1 [H : El (list prd)] [R : El prd] :
  âŸ (H âŸ not VRAI => R);

symbol VR2 [H : El (list prd)] :
  âŸ (H âŸ VRAI) â†’
  âŸ (H âŸ not VRAI);

symbol VR3 [H : El (list prd)] [R : El prd] :
  âŸ (H âŸ R) â†’
  âŸ (H âŸ VRAI => R);

symbol VR4 [H : El (list prd)] [R : El prd] :
  âŸ (H âŸ VRAI);

symbol FX1 [H : El (list prd)] [R : El prd] :
  âŸ (H âŸ R) â†’
  âŸ (H âŸ not VRAI => R);

symbol FX2 [H : El (list prd)] [R : El prd] :
  âŸ (H âŸ not VRAI);

symbol FX3 [H : El (list prd)] [R : El prd] :
  âŸ (H âŸ VRAI => R);


// ----------------------------------------------
// 5.10. STOP rules
// ----------------------------------------------
symbol STOP [H : El (list prd)] [P : El prd] :
  Prf (Â¬ (P â‰ˆ FAUX)) â†’
  âŸ (H âŸ not P => FAUX) â†’
  âŸ (H âŸ P);

symbol STOP' [H : El (list prd)] [P : El prd] :
  Prf ((H âŸ P) âŸ¿ P);

// ----------------------------------------------
// 5.11 INS rule
// ----------------------------------------------
symbol â­† : El (list prd â¤³ prd â¤³ prd);
notation â­† infix 5;

rule (nil â­† $p) â†ª $p
with (($q âˆ· $qs) â­† $p) â†ª $q => ($qs â­† $p);

symbol INS [H Q : El (list prd)] :
  âŸ (H âŸ Q â­† FAUX) â†’
  âŸ (H âŸ FAUX);

// ----------------------------------------------
// 5.12. Normalization rules
// ----------------------------------------------
symbol NRM1 [H : El (list prd)] [P : El prd] [S : El prd] :
  âŸ (H âŸ P => S) â†’
  âŸ (H âŸ (`â™¢ _, P) => S);

symbol NRM2 [H : El (list prd)] [P Q S : El prd] :
  âŸ (H âŸ P => (`â™¢ x, Q) => S) â†’
  âŸ (H âŸ `â™¢ x, (P => Q) => S);

symbol NRM3 [H : El (list prd)] [P Q S : El prd] :
  Prf (Â¬ (Q â‰ˆ FAUX)) â†’
  âŸ (H âŸ (Q => S) and ((`! x, not P) => S)) â†’
  âŸ (H âŸ `â™¢ x, (P => Q) => S);

symbol NRM4 [H : El (list prd)] [P Q R S : El prd] :
  âŸ (H âŸ (Q => `â™¢ x, (P => R)) => S) â†’
  âŸ (H âŸ `â™¢ x, (P => (Q => R)) => S);

symbol NRM5 [H : El (list prd)] [P Q R S : El prd] :
  âŸ (H âŸ `â™¢ x, (P and Q => R) => S) â†’
  âŸ (H âŸ `â™¢ x, (P => (Q => R)) => S);

symbol NRM6 [H : El (list prd)] [P Q R S : El prd] :
  âŸ (H âŸ `â™¢ x, (R => P) => (`â™¢ x, (R => Q) => S)) â†’
  âŸ (H âŸ `â™¢ x, (R => P and Q) => S);

symbol NRM7 [H : El (list prd)] [P Q S : El prd] :
  âŸ (H âŸ (`â™¢ x, P) => ((`â™¢ x, Q) => S)) â†’
  âŸ (H âŸ (`â™¢ x, (P and Q) => S));

symbol NRM8 [H : El (list prd)] [Q S : El prd] :
  âŸ (H âŸ (`â™¢ x, `â™¢ y, Q) => S) â†’
  âŸ (H âŸ (`â™¢ x, `! y, Q) => S);

symbol NRM9 [H : El (list prd)] [P Q S : El prd] :
  âŸ (H âŸ `â™¢ x, `â™¢ y, (P => Q) => S) â†’
  âŸ (H âŸ `â™¢ x, (P => `! y, Q) => S);

symbol NRM10 [H : El (list prd)] [P Q R : El prd] :
  âŸ (H âŸ `â™¡ x, not (P and Q) => R) â†’
  âŸ (H âŸ `â™¢ x, (P and Q => FAUX) => R);

symbol NRM11 [H : El (list prd)] [P R : El prd] :
  âŸ (H âŸ `â™¡ x, not (VRAI and P) => R) â†’
  âŸ (H âŸ `â™¢ x, (P => FAUX) => R);

symbol NRM12 [H : El (list prd)] [P Q R : El prd] :
  âŸ (H âŸ `â™¡ x, not (P and Q) => R) â†’
  âŸ (H âŸ `â™¢ x, (P => not Q) => R);

symbol NRM13 [H : El (list prd)] [P Q R : El prd] :
  âŸ (H âŸ `â™¡ x, not (P and not Q) => R) â†’
  âŸ (H âŸ `â™¢ x, (P => Q) => R);

symbol NRM14 [H : El (list prd)] [P R : El prd] :
  âŸ (H âŸ `â™¡ x, not (VRAI and P) => R) â†’
  âŸ (H âŸ (`â™¢ x, not P) => R);

symbol NRM15 [H : El (list prd)] [P R : El prd] :
  âŸ (H âŸ `â™¡ x, not (VRAI and not P) => R) â†’
  âŸ (H âŸ (`â™¢ x, P) => R);

symbol NRM16 [H : El (list prd)] [P : El (exp â¤³ prd)] [Q : El prd] :
  Prf (elem (! P) H) â†’
  âŸ (H âŸ Q) â†’
  âŸ (H âŸ (â™¡ P) => Q);

// hopefully higher-order unification sorts this out
symbol NRM17 [H : El (list prd)] [P : El (exp â¤³ prd)] [Q : El prd] [E : El exp] :
  Prf (elem (`! x, not (VRAI and P x)) H) â†’
  âŸ (H âŸ (`â™¡ y, not (VRAI and not (P E))) => Q);

symbol NRM18 [H : El (list prd)] [P : El (exp â¤³ prd)] [R Q : El prd] [E : El exp] :
  Prf (elem (`! x, not (VRAI and not (P x))) H) â†’
  Prf (P E â‰ˆ R) â†’
  âŸ (H âŸ (`â™¡ y, not (VRAI and R)) => Q);

symbol NRM19 [H : El (list prd)] [R : El (exp â¤³ prd)] [P Q : El prd] [E : El exp] :
  Prf (elem P H) â†’
  Prf ((R E) â‰ˆ P) â†’
  âŸ (H âŸ (`â™¡ x, not (VRAI and (R x))) => Q);

symbol NRM20 [H : El (list prd)] [P : El (exp â¤³ prd)] [Q : El prd] [E : El exp] :
  âŸ (H âŸ `â™¡ y, not (P E) => Q) â†’
  âŸ (H âŸ `â™¡ x, `â™¡ y, not (P x and (E = x)) => Q);

symbol NRM21 [H : El (list prd)] [P : El (exp â¤³ prd)] [Q : El prd] [E : El exp] :
  âŸ (H âŸ `â™¡ y, not (P E) => Q) â†’
  âŸ (H âŸ `â™¡ x, `â™¡ y, not (P x and (x = E)) => Q);

symbol NRM22 [H : El (list prd)] [P : El (exp â¤³ prd)] [Q : El prd] [E : El exp] :
  âŸ (H âŸ not (P E) => Q) â†’
  âŸ (H âŸ `â™¡ x, not (P x and (x = E)) => Q);

symbol NRM23 [H : El (list prd)] [P : El (exp â¤³ prd)] [Q : El prd] [E : El exp] :
  âŸ (H âŸ not (P E) => Q) â†’
  âŸ (H âŸ `â™¡ x, not (P x and (E = x)) => Q);

sequential symbol NRM24_aux : El (prd â¤³ bool);

rule NRM24_aux ($A and $B) â†ª âŠ¥
with NRM24_aux  _          â†ª âŠ¥;

symbol NRM24 [H : El (list prd)] [P Q : El prd] :
  Prf (NRM24_aux P) â†’
  âŸ (H âŸ `â™¡ x, not (VRAI and P) => Q) â†’
  âŸ (H âŸ `â™¡ x, not P => Q);

symbol NRM25 [H : El (list prd)] [P : El prd] :
  âŸ (H âŸ P) â†’
  âŸ (H âŸ `â™¡ x, P);

symbol NRM26 [H : El (list prd)] [P : El (exp â¤³ prd)] :
  âŸ (H âŸ `â™¡ x, P x) â†’
  âŸ (H âŸ `â™¡ x, `â™¡ y, P x);

// ---- not yet implemented, possibly requires manipulation of variables? ------
symbol NRM27 [H : El (list prd)] [P Q : El prd] : TYPE;

symbol NRM29 [H : El (list prd)] [P Q S R : El prd] [a b : El exp] : TYPE;

symbol NRM29_1 [H : El (list prd)] [P Q S R : El prd] [a b : El exp] : TYPE;
// -----------------------------------------------------------------------------

symbol NRM30 [H : El (list prd)] [P' : El (exp â¤³ prd)] [S R : El prd] [a b x : El exp] :
  Prf (elem ((a + x) â‰¤ ğŸ) (to_list (P' x))) â†’
  Prf (elem ((b - x) â‰¤ ğŸ) (to_list (P' x))) â†’
  Prf (ev (a + b = ğŸ)) â†’
  âŸ (H âŸ not (P' b) => R) â†’
  âŸ (H âŸ `â™¡ x, not (P' x) => R);

symbol NRM30_1 [H : El (list prd)] [P' : El (exp â¤³ prd)] [S R : El prd] [a b x : El exp] :
  Prf (elem ((x + a) â‰¤ ğŸ)   (to_list (P' x))) â†’
  Prf (elem ((â¨ª x + b) â‰¤ ğŸ) (to_list (P' x))) â†’
  Prf (ev (a + b = ğŸ)) â†’
  âŸ (H âŸ not (P' b) => R) â†’
  âŸ (H âŸ `â™¡ x, not (P' x) => R);

// redunant rules??
symbol NRM8_1 : TYPE;
symbol NRM9_1 : TYPE;


// ----------------------------------------------
// 5.13. Rules for equality
// ----------------------------------------------
symbol EVR1 [H : El (list prd)] [P : El prd] [E : El exp] :
  âŸ (H âŸ not (E = E) => P);

symbol EVR11 [H : El (list prd)] [P : El prd] [n m : El exp] :
  Prf (ev (n != m)) â†’
  Prf (n âˆˆ â„•) â†’
  Prf (m âˆˆ â„•) â†’
  âŸ (H âŸ (n = m) => P);

symbol EVR2 [H : El (list prd)] [E : El exp] :
  âŸ (H âŸ FAUX) â†’
  âŸ (H âŸ not (E = E));

symbol EVR3 [H : El (list prd)] [P : El prd] [E : El exp] :
  âŸ (H âŸ P) â†’
  âŸ (H âŸ (E = E) => P);

symbol EVR4 [H : El (list prd)] [E : El exp] :
  âŸ (H âŸ (E = E));

symbol EAXM1 [H : El (list prd)] [E F : El exp] [P : El prd] :
  Prf (elem (not (F = E)) H) â†’
  âŸ (H âŸ (E = F) => P);

symbol EAXM2 [H : El (list prd)] [E F : El exp] [P : El prd] :
  Prf (elem (F = E) H) â†’
  âŸ (H âŸ not (E = F) => P);

symbol EAXM3_1 [H : El (list prd)] [E F : El exp] [P : El prd] :
  Prf (elem (F = E) H) â†’
  âŸ (H âŸ (E = F));

symbol EAXM3_2 [H : El (list prd)] [E F : El exp] [P : El prd] :
  Prf (elem (not (F = E)) H) â†’
  âŸ (H âŸ not (E = F));

symbol EIMP5_1 [H : El (list prd)] [E F : El exp] [P : El prd] :
  Prf (elem (not (F = E)) H) â†’
  âŸ (H âŸ P) â†’
  âŸ (H âŸ not (E = F) => P);

symbol EIMP5_2 [H : El (list prd)] [E F : El exp] [P : El prd] :
  Prf (elem (F = E) H) â†’
  âŸ (H âŸ P) â†’
  âŸ (H âŸ (E = F) => P);

symbol EQC1 [H : El (list prd)] [a b c d : El exp] [P : El prd] :
  âŸ (H âŸ not (a = c) or not (b = d) => P) â†’
  âŸ (H âŸ not (opair a b = opair c d) => P);

symbol EQC2 [H : El (list prd)] [a b c d : El exp] [P : El prd] :
  âŸ (H âŸ (a = c) and (b = d) => P) â†’
  âŸ (H âŸ  (opair a b = opair c d) => P);

symbol EQS1 [H : El (list prd)] [E F : El exp] [P : El prd] :
  âŸ (H âŸ (E = F) => P) â†’
  âŸ (H âŸ (eql_set E F) => P);

symbol EQS2 [H : El (list prd)] [E F : El exp] [P : El prd] :
  âŸ (H âŸ FAUX => P) â†’
  âŸ (H âŸ not (eql_set E F) => P);

symbol EAXM9_1 [H : El (list prd)] [p q : El (exp â¤³ exp)] [E : El exp] [Q : El prd] :
  Prf (elem (`! x, not (VRAI and (p x = q x))) H) â†’
  âŸ (H âŸ ((p E) = (q E)) => Q);

symbol EAXM9_2 [H : El (list prd)] [p q : El (exp â¤³ exp)] [E : El exp] [Q : El prd] :
  Prf (elem (`! x, not (VRAI and not (p x = q x))) H) â†’
  âŸ (H âŸ not ((p E) = (q E)) => Q);

symbol OPR1 [H : El (list prd)] [P : El (exp â¤³ prd)] [x E : El exp] :
  âŸ (H âŸ P E) â†’
  âŸ (H âŸ (x = E) => P x);

symbol OPR2 [H : El (list prd)] [P : El (exp â¤³ prd)] [x E : El exp] :
  âŸ (H âŸ P E) â†’
  âŸ (H âŸ (E = x) => P x);

symbol ECTR1 [H : El (list prd)] [P : El prd] [Q : El (exp â¤³ prd)] [E F : El exp] :
  Prf (elem (not (Q E)) H) â†’
  Prf (elem (Q F) H) â†’
  âŸ (H âŸ (E = F) => P);

symbol ECTR2 [H : El (list prd)] [P : El prd] [Q : El (exp â¤³ prd)] [E F : El exp] :
  Prf (elem (not (Q E)) H) â†’
  Prf (elem (Q F) H) â†’
  âŸ (H âŸ (F = E) => P);

symbol ECTR3 [H : El (list prd)] [Q : El prd] [P : El (exp â¤³ prd)] [E F : El exp] :
  Prf (elem (E = F) H) â†’
  Prf (elem (P F) H) â†’
  âŸ (H âŸ not (P E) => Q);

symbol ECTR4 [H : El (list prd)] [Q : El prd] [P : El (exp â¤³ prd)] [E F : El exp] :
  Prf (elem (F = E) H) â†’
  Prf (elem (P F) H) â†’
  âŸ (H âŸ not (P E) => Q);

symbol ECTR5 [H : El (list prd)] [Q : El prd] [P : El (exp â¤³ prd)] [E F : El exp] :
  Prf (elem (E = F) H) â†’
  Prf (elem (not (P F)) H) â†’
  âŸ (H âŸ P E => Q);

symbol ECTR6 [H : El (list prd)] [Q : El prd] [P : El (exp â¤³ prd)] [E F : El exp] :
  Prf (elem (F = E) H) â†’
  Prf (elem (not (P F)) H) â†’
  âŸ (H âŸ P E => Q);


// ----------------------------------------------
// 5.14. Rules for arithmetic
// ----------------------------------------------
symbol AR1 [H : El (list prd)] [E : El exp] [R : El prd] :
  âŸ (H âŸ R) â†’
  âŸ (H âŸ (E â‰¤ E) => R);

symbol AR2 [a b : El exp] [H : El (list prd)] [R : El prd] :
  Prf (ev (a > b)) â†’
  âŸ (H âŸ a â‰¤ b => R);

symbol AR3 [a : El exp] [H : El (list prd)] [R : El prd] :
  âŸ (H âŸ ((ğŸ - a) â‰¤ ğŸ) => R) â†’
  âŸ (H âŸ not (a â‰¤ ğŸ) => R);

symbol AR4 [E F : El exp] [H : El (list prd)] [R : El prd] :
  Prf (elem (F â‰¤ ğŸ) H) â†’
  Prf (ev ((E + F) > ğŸ)) â†’
  âŸ (H âŸ E â‰¤ ğŸ => R);

symbol AR5 [a : El exp] [H : El (list prd)] [R : El prd] :
  Prf (elem (a â‰ª ğŸ) H) â†’
  âŸ (H âŸ (a = ğŸ => (â¨ª a â‰¤ ğŸ => R))) â†’
  âŸ (H âŸ â¨ª a â‰¤ ğŸ => R);

symbol AR6 [a : El exp] [H : El (list prd)] [R : El prd] :
  Prf (elem (â¨ª a â‰ª ğŸ) H) â†’
  âŸ (H âŸ (a = ğŸ => (a â‰¤ ğŸ => R))) â†’
  âŸ (H âŸ a â‰¤ ğŸ => R);

symbol AR7 [a b c : El exp] [H : El (list prd)] [R : El prd] :
  Prf (elem ((c + b) â‰ª ğŸ) H) â†’
  Prf (ev ((a + c) = ğŸ)) â†’
  âŸ (H âŸ (a = b) => ((a - b) â‰¤ ğŸ) => R) â†’
  âŸ (H âŸ ((a - b) â‰¤ ğŸ) => R);

symbol AR8 [a b c : El exp] [H : El (list prd)] [R : El prd] :
  Prf (elem ((a - b) â‰ª ğŸ) H) â†’
  Prf (ev ((a + c) = ğŸ)) â†’
  âŸ (H âŸ (a = b) => ((c + b) â‰¤ ğŸ) => R) â†’
  âŸ (H âŸ ((c + b) â‰¤ ğŸ) => R);

symbol AR9 [E F : El exp] [H : El (list prd)] [R : El prd] :
  Prf (ev E â‰ˆ F) â†’
  âŸ (H âŸ (F â‰¤ ğŸ) => R) â†’
  âŸ (H âŸ (E â‰¤ ğŸ) => R);

symbol AR10 [H : El (list prd)] [P Q R : El prd] :
  Prf (ev P â‰ˆ Q) â†’
  âŸ (H âŸ Q => R) â†’
  âŸ (H âŸ P => R);

symbol AR11 [x : El exp] [H : El (list prd)] [P : El prd] :
  âŸ (H âŸ not (x â‰¤ x) => P);

symbol AR12 [a b : El exp] [H : El (list prd)] [P : El prd] :
  âŸ ((a â‰¤ b) âˆ· H âŸ (a â‰¤ b) => P);


// ----------------------------------------------
// 5.15 Booleans
// ----------------------------------------------
// in contrast to `VRAI` and `FAUX` in `VRFX` (both of type `prd`),
// the rules in this file operate on boolean values of type `exp`.
// ----------------------------------------------
symbol FALSE : El exp;
symbol TRUE : El exp;

symbol BOOL1_1 [H : El (list prd)] [P : El prd] [v : El exp] :
  âŸ ((not (v = FALSE)) âˆ· (v = TRUE) âˆ· H âŸ P) â†’
  âŸ (H âŸ (v = TRUE) => P);

symbol BOOL1_2 [H : El (list prd)] [P : El prd] [v : El exp] :
  âŸ ((v = FALSE) âˆ· (not (v = TRUE)) âˆ· H âŸ P) â†’
  âŸ (H âŸ (v = FALSE) => P);

symbol BOOL2_1 [H : El (list prd)] [P : El prd] [v : El exp] :
  âŸ (H âŸ (v = TRUE) => P) â†’
  âŸ (H âŸ (TRUE = v) => P);

symbol BOOL2_2 [H : El (list prd)] [P : El prd] [v : El exp] :
  âŸ (H âŸ (v = FALSE) => P) â†’
  âŸ (H âŸ (FALSE = v) => P);

symbol BOOL3_1 [H : El (list prd)] [P : El prd] [v : El exp] :
  âŸ (H âŸ (v = FALSE) => P) â†’
  âŸ (H âŸ not (v = TRUE) => P);

symbol BOOL3_2 [H : El (list prd)] [P : El prd] [v : El exp] :
  âŸ (H âŸ (v = TRUE) => P) â†’
  âŸ (H âŸ not (v = FALSE) => P);

symbol BOOL4_1 [H : El (list prd)] [P : El prd] [v : El exp] :
  âŸ (H âŸ (v = FALSE) => P) â†’
  âŸ (H âŸ not (TRUE = v) => P);

symbol BOOL4_2 [H : El (list prd)] [P : El prd] [v : El exp] :
  âŸ (H âŸ (v = TRUE) => P) â†’
  âŸ (H âŸ not (FALSE = v) => P);

symbol BOOL5_1 [H : El (list prd)] [P : El prd] [v : El exp] :
  âŸ (H âŸ (TRUE = FALSE) => P);

symbol BOOL5_2 [H : El (list prd)] [P : El prd] [v : El exp] :
  âŸ (H âŸ (FALSE = TRUE) => P);
::::::::::::::
Syntax.lp
::::::::::::::
require open Logic.U.Set Logic.U.Prop Logic.U.Arrow Logic.U.Quant;
require open pp2lp.Prelude;

// ------ predicates, expressions, formulas ------
symbol prd : Set;
symbol exp : Set;
symbol frm : Set;

// ------ primitive logical symbols --------------
injective symbol and : El (prd â¤³ prd â¤³ prd);
injective symbol or : El (prd â¤³ prd â¤³ prd);
injective symbol => : El (prd â¤³ prd â¤³ prd);
injective symbol <=> : El (prd â¤³ prd â¤³ prd);
injective symbol not : El (prd â¤³ prd);
injective symbol ! : El ((exp â¤³ prd) â¤³ prd);
injective symbol # : El ((exp â¤³ prd) â¤³ prd);
injective symbol =  : El (exp â¤³ exp â¤³ prd);
injective symbol != : El (exp â¤³ exp â¤³ prd);
injective symbol â„² : El (frm â¤³ prd);

notation =  infix left 2;
notation != infix left 2;
notation and infix left 2;
notation or  infix left 2;
notation =>  infix left 2;
notation <=> infix left 1;
notation not prefix 3;

notation ! quantifier;
notation # quantifier;


// ------ Sequents ---------------------------
symbol seq : Set;

injective symbol âŸ : El (list prd â¤³ prd â¤³ seq);
notation âŸ infix 0;

injective symbol âŸ  : El seq â†’ TYPE;
// derivability. e.g.,
symbol
  AND2 [H : El (list prd)] [P Q : El prd] :
    âŸ (H âŸ P => not Q) â†’
    âŸ (H âŸ not (P and Q));

// mysterious arrow relation
symbol âŸ¿ : El (seq â¤³ prd â¤³ bool);
notation âŸ¿ infix 0;


// ----- Misc symbols -----------------------
// booleans
symbol VRAI : El prd;
symbol FAUX : El prd;

// arithmetic
symbol > : El (exp â¤³ exp â¤³ prd);
symbol â‰¤ : El (exp â¤³ exp â¤³ prd);
symbol < : El (exp â¤³ exp â¤³ prd);
symbol â‰ª : El (exp â¤³ exp â¤³ prd);
symbol ğŸ : El (exp);
symbol ğŸ : El (exp);
symbol â¨ª : El (exp â¤³ exp);
symbol + : El (exp â¤³ exp â¤³ exp);
symbol - : El (exp â¤³ exp â¤³ exp);

notation > infix 5;
notation â‰¤ infix 5;
notation < infix 5;
notation â‰ª infix 5;
notation + infix 5;
notation - infix 5;

// mystery quantifiers
symbol â™¢ : El ((exp â¤³ prd) â¤³ prd);
symbol â™¡ : El ((exp â¤³ prd) â¤³ prd);
notation â™¢ quantifier;
notation â™¡ quantifier;


// ----- Operations on terms -----------------------

// syntactic equality on predicates
rule FAUX â‰ˆ FAUX â†ª âŠ¤
with VRAI â‰ˆ VRAI â†ª âŠ¤
with (not $p) â‰ˆ (not $q)           â†ª ($p â‰ˆ $q)
with ($p1 and $p2) â‰ˆ ($q1 and $q2) â†ª ($p1 â‰ˆ $q1) âˆ§ ($p2 â‰ˆ $q2)
with ($p1 or $p2) â‰ˆ ($q1 or $q2)   â†ª ($p1 â‰ˆ $q1) âˆ§ ($p2 â‰ˆ $q2)
with ($p1 => $p2) â‰ˆ ($q1 => $q2)   â†ª ($p1 â‰ˆ $q1) âˆ§ ($p2 â‰ˆ $q2)
with ($p1 <=> $p2) â‰ˆ ($q1 <=> $q2) â†ª ($p1 â‰ˆ $q1) âˆ§ ($p2 â‰ˆ $q2)
with ($e1 = $e2) â‰ˆ ($f1 = $f2)     â†ª ($e1 â‰ˆ $f1) âˆ§ ($e2 â‰ˆ $f2)
with ($e1 != $e2) â‰ˆ ($f1 != $f2)   â†ª ($e1 â‰ˆ $f1) âˆ§ ($e2 â‰ˆ $f2)
with (! $P) â‰ˆ (! $Q) â†ª (`âˆ€ x, ($P x â‰ˆ $Q x))
with (# $P) â‰ˆ (# $Q) â†ª (`âˆ€ x, ($P x â‰ˆ $Q x))
with (â™¢ $P) â‰ˆ (â™¢ $Q) â†ª (`âˆ€ x, ($P x â‰ˆ $Q x))
with (â™¡ $P) â‰ˆ (â™¡ $Q) â†ª (`âˆ€ x, ($P x â‰ˆ $Q x));

// evaluation
symbol ev [a : Set] [b : Set] : El (a â¤³ b);

// meta-level naturals?
symbol â„• : Set;
symbol âˆˆ : El exp â†’ Set â†’ El bool;
notation âˆˆ infix 5;

// ordered pairs, set equality ??
symbol opair : El (exp â¤³ exp â¤³ exp);
symbol eql_set : El (exp â¤³ exp â¤³ prd);

sequential symbol to_list : El (prd â¤³ list prd);
rule to_list ($x and $xs) â†ª $x âˆ· (to_list $xs)
with to_list $p           â†ª nil;

sequential symbol conj : El (list prd â¤³ prd);
rule conj ($x âˆ· nil) â†ª $x
with conj ($x âˆ· $xs) â†ª $x and (conj $xs)
with conj nil        â†ª FAUX;
::::::::::::::
Traces.lp
::::::::::::::
require open Logic.U.Set Logic.U.Prop Logic.U.Arrow;
require open pp2lp.Prelude pp2lp.Syntax pp2lp.Rules;

injective symbol âœ“ : El prd â†’ TYPE;
// theorem, derivable sequent with no hypothesis.
rule (âœ“ $P) â†ª âŸ (nil âŸ $P);


symbol {|05.trace|} [p q] :
  âœ“ (not (p or q) => not p) â‰”
begin
  assume p q;
  simplify;
  apply OR1;
  apply IMP4;
  apply AXM4;
  simplify elem;
  refine TOP;
end;


symbol {|06.trace|} [p q] :
  âœ“ (not (p and (not p) or (q and not q))) â‰”
begin
  assume p q;
  simplify;
  apply OR2
  {
    apply AND2;
    apply IMP4;
    apply NOT2;
    apply AXM3;
    simplify elem;
    refine TOP;
  }{
    apply AND2;
    apply IMP4;
    apply NOT2;
    apply AXM3;
    simplify elem;
    refine TOP;
  };
end;


symbol {|07.trace|} [p q] :
  âœ“ ((p or q) => (q or p)) â‰”
begin
  assume p q;
  simplify;
  apply OR3
  {
    apply IMP4;
    apply OR4;
    apply AXM2;
    simplify elem;
    refine TOP;
  }{
    apply IMP4;
    apply OR4;
    apply AXM4;
    simplify elem;
    refine TOP;
  };
end;

symbol {|08.trace|} [p q] :
  âœ“ (not (p => q) => not q) â‰”
begin
  assume p q;
  simplify;
  apply IMP1;
  apply IMP4;
  apply AXM7;
end;


symbol {|09.trace|} [p] :
  âœ“ (not ((p or not p) => (p and not p))) â‰”
begin
  assume p;
  simplify;
  apply IMP2
  {
    apply AND2;
    apply IMP4;
    apply NOT2;
    apply AXM3;
    simplify elem;
    refine TOP;
  }{
    apply OR4;
    apply AXM7;
  };
end;


symbol {|10.trace|} [p] :
  âœ“ (p => not p => not p) â‰”
begin
  assume p;
  simplify;
  apply IMP3
  {
    apply AXM7;
  }{
    apply AXM7;
  };
end;

symbol {|11.trace|} [p] :
  âœ“ (p => (p => p and p)) â‰”
begin
  assume p;
  simplify;
  apply IMP4;

  // apply IMP5 (1);
  // apply AND4;
  // apply AXM3;
  // apply AXM3;
abort;

symbol {|12.trace|} [p q] :
  âœ“ (not (p <=> p) => q) â‰”
begin
  assume p q;
  simplify;
  apply EQV1 {
    apply IMP4;
    apply AXM2;
    simplify elem;
    refine TOP;
  }{
    apply IMP4;
    apply AXM1;
    simplify elem;
    refine TOP;
  };
end;

symbol {|13.trace|} [p] :
  âœ“ (not (p <=> not p)) â‰”
begin
  assume p;
  simplify;
  apply EQV2 {
    apply IMP4;
    apply NOT2;
    apply AXM3;
    simplify elem;
    refine TOP;
  } {
    apply NOT1;
    apply AXM7;
  };
end;

symbol {|14.trace|} [p q] :
  âœ“ ((p <=> not(p)) => q) â‰”
begin
  assume p q;
  simplify;
  apply EQV3 {
    apply IMP4;
    apply AXM2;
    simplify elem;
    refine TOP;
  } {
    apply IMP4;
    apply NOT1;
    apply AXM1;
    simplify elem;
    refine TOP;
  };
end;

symbol {|15.trace|} [p] :
  âœ“ (p <=> p) â‰”
begin
  assume p;
  simplify;
  apply EQV4
    { apply AXM7 }
    { apply AXM7 };
end;

symbol {|16.trace|} [p q r] :
  âœ“ (not q => (p => (q => r))) â‰”
begin
  assume p q r;
  simplify;
  apply IMP4;
  apply AXM5;
  simplify elem;
  refine TOP;
end;

symbol {|17.trace|} [p q r] :
  âœ“ (q => (p => (not q => r))) â‰”
begin
  assume p q r;
  simplify;
  apply IMP4;
  apply AXM6;
  simplify elem;
  refine TOP;
end;

symbol {|18.trace|} [p q r] :
  âœ“ (not q => (p => (q => r))) â‰”
begin
  assume p q r;
  simplify;
  apply IMP4;
  apply AXM5;
  simplify elem;
  refine TOP;
end;

symbol {|19.trace|} [p q r] :
  âœ“ (not q => (p => (q => r))) â‰”
begin
  assume p q r;
  simplify;
  apply IMP4;
  apply AXM5;
  simplify elem;
  refine TOP;
end;
symbol foo : El (exp â¤³ prd);


symbol {|22.trace|} :
  âœ“ (not (`! x, `! y, not (x = x))) â‰”
begin
  simplify;
  apply ALL2;
  apply ALL6;
abort;


//symbol {|20.trace|} [p ] :
//  âœ“ (not (`! x,`! y, x = y) => (p or not p)) â‰”
//begin
//  assume p;
//  simplify;
//  apply ALL1;
//  apply ALL5;
//  apply ALL8;
//  //apply AXM5;
//  //simplify elem;
//  //refine TOP;
//end;
