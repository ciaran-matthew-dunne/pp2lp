require open Logic.U.Set Logic.U.Prop;
require open Logic.U.Arrow Logic.U.DepArrow Logic.U.Quant;
require open pp2lp.Prelude;



// ------ predicates, expressions, formulas ------
symbol idt â‰” string;
symbol vrb â‰” list idt;

symbol Frm : TYPE;

inductive Exp : TYPE â‰”
  | VAR : El idt â†’ Exp
  | ZERO : Exp
  | ONE : Exp
  | MINUS : Exp â†’ Exp â†’ Exp
  | ADD : Exp â†’ Exp â†’ Exp
  | SUB : Exp â†’ Exp â†’ Exp
with Prd : TYPE â‰”
  | AND : Prd â†’ Prd â†’ Prd
  | OR  : Prd â†’ Prd â†’ Prd
  | IMPL : Prd â†’ Prd â†’ Prd
  | IFF  : Prd â†’ Prd â†’ Prd
  | NOT : Prd â†’ Prd
  | ALL : El vrb â†’ Prd â†’ Prd
  | EXI : El vrb â†’ Prd â†’ Prd
  | EQ  : Exp â†’ Exp â†’ Prd
  | ATOM : Frm â†’ Prd;

symbol prd : Set;
symbol exp : Set;
symbol frm : Set;

rule El prd â†ª Prd;
rule El exp â†ª Exp;
rule El frm â†ª Frm;



// ------ primitive logical symbols --------------
injective symbol and  â‰” AND;
injective symbol or   â‰” OR;
injective symbol =>   â‰” IMPL;
injective symbol <=>  â‰” IFF;
injective symbol not  â‰” NOT;
injective symbol =    â‰” EQ;
injective symbol atom â‰” ATOM;
injective symbol ! â‰” ALL;
injective symbol # â‰” EXI;

notation =   infix left 2;
notation and infix left 2;
notation or  infix left 2;
notation =>  infix left 2;
notation <=> infix left 1;
notation not prefix 3;

// mystery quantifiers
injective symbol â™¢ : El (vrb â¤³ prd â¤³ prd);  // aka. forall
injective symbol â™¡ : El (vrb â¤³ prd â¤³ prd); // aka. forall2

symbol VRAI : El prd;
symbol FAUX : El prd;

// not equal
injective symbol != (a b : El exp) â‰” not (a = b);
notation !=  infix left 2;


// ----- Arithmetic -----------------------
// similarly for arithmetic relation symbols, why are these not in the grammar for prd?

symbol > : El (exp â¤³ exp â¤³ prd);
symbol â‰¤ : El (exp â¤³ exp â¤³ prd);
symbol < : El (exp â¤³ exp â¤³ prd);
symbol â‰ª : El (exp â¤³ exp â¤³ prd);
symbol ðŸŽ : El (exp);
symbol ðŸ : El (exp);
symbol â¨ª : El (exp â¤³ exp);
symbol + : El (exp â¤³ exp â¤³ exp);
symbol - : El (exp â¤³ exp â¤³ exp);

notation > infix 5;
notation â‰¤ infix 5;
notation < infix 5;
notation â‰ª infix 5;
notation + infix 5;
notation - infix 5;


// ------ Sequents ---------------------------
symbol seq : Set;
symbol Seq â‰” El seq;
injective symbol âŸ : El ((list prd) â¤³ prd â¤³ seq);
notation âŸ infix 0;

// sequent derivations
injective symbol â–· : El seq â†’ TYPE;
injective symbol âŠ© : El (list prd) â†’ El prd â†’ Set;
notation âŠ© infix 0;
rule El ($H âŠ© $P) â†ª â–· ($H âŸ $P);

// type-level side-conditions
symbol If : El bool â†’ Set â†’ TYPE;
rule If âŠ¤ $X â†ª El $X;

symbol Thm : Prd â†’ TYPE â‰”
  Î» p, (â–· (nil âŸ p));


// ---- Results ------------------------------
injective symbol Res : Seq â†’ TYPE;
symbol obtain [Î£ : Seq] : Res Î£ â†’ El prd;

coerce_rule coerce (Res $Î£) Prd $Ï â†ª obtain $Ï;

// ----- Operations on terms -----------------------

// syntactic equality on expressions and predicates.
sequential symbol == [a : Set] : El (a â¤³ a â¤³ bool);
sequential symbol !== [a : Set] : El (a â¤³ a â¤³ bool);

notation == infix 5;
notation !== infix 5;

rule ($X !== $Y) â†ª ite ($X == $Y) âŠ¥ âŠ¤;

rule ((==) [string] $x $x) â†ª âŠ¤
with ((==) [string] _  _)  â†ª âŠ¥;

rule FAUX == FAUX â†ª âŠ¤
with VRAI == VRAI â†ª âŠ¤
with (not $p) == (not $q)           â†ª ($p == $q)
with ($p1 and $p2) == ($q1 and $q2) â†ª ($p1 == $q1) âˆ§ ($p2 == $q2)
with ($p1 or $p2) == ($q1 or $q2)   â†ª ($p1 == $q1) âˆ§ ($p2 == $q2)
with ($p1 => $p2) == ($q1 => $q2)   â†ª ($p1 == $q1) âˆ§ ($p2 == $q2)
with ($p1 <=> $p2) == ($q1 <=> $q2) â†ª ($p1 == $q1) âˆ§ ($p2 == $q2)
with ($e1 = $e2) == ($f1 = $f2)     â†ª ($e1 == $f1) âˆ§ ($e2 == $f2)
with ($e1 != $e2) == ($f1 != $f2)   â†ª ($e1 == $f1) âˆ§ ($e2 == $f2);
//with (! $P) == (! $Q) â†ª (`âˆ€ x, ($P x == $Q x))
//with (# $P) == (# $Q) â†ª (`âˆ€ x, ($P x == $Q x))
//with (â™¢ $P) == (â™¢ $Q) â†ª (`âˆ€ x, ($P x == $Q x))
//with (â™¡ $P) == (â™¡ $Q) â†ª (`âˆ€ x, ($P x == $Q x`));


// ------- free vars, substitution ----------------
symbol free [a : Set] : El (idt â¤³ a â¤³ bool);
rule free $x (AND $P $Q)  â†ª (free $x $P) âˆ¨ (free $x $Q)
with free $x (OR $P $Q)   â†ª (free $x $P) âˆ¨ (free $x $Q)
with free $x (IMPL $P $Q) â†ª (free $x $P) âˆ¨ (free $x $Q)
with free $x (IFF $P $Q)  â†ª (free $x $P) âˆ¨ (free $x $Q)
with free $x (NOT $P)     â†ª free $x $P
with free $x (ALL $vs $P) â†ª (free $x $P) âˆ§ Â¬($x âˆˆ $vs)
with free $x (EXI $vs $P) â†ª (free $x $P) âˆ§ Â¬($x âˆˆ $vs)
with free $x (EQ $e1 $e2) â†ª (free $x $e1) âˆ¨ (free $x $e2)
with free $x (ATOM $f)    â†ª free $x $f;

symbol subst [a : Set] : El (idt â¤³ exp â¤³ a â¤³ a);
rule subst $x $t (VAR $y)     â†ª ite ($x == $y) $t (VAR $y)
with subst $x $t (AND $P $Q)  â†ª AND (subst $x $t $P) (subst $x $t $Q)
with subst $x $t (OR $P $Q)   â†ª OR (subst $x $t $P) (subst $x $t $Q)
with subst $x $t (IMPL $P $Q) â†ª IMPL (subst $x $t $P) (subst $x $t $Q)
with subst $x $t (IFF $P $Q)  â†ª IFF (subst $x $t $P) (subst $x $t $Q)
with subst $x $t (NOT $P)     â†ª NOT (subst $x $t $P)
with subst $x $t (ALL $vs $P) â†ª ite ($x âˆˆ $vs) (ALL $vs $P) (ALL $vs (subst $x $t $P))
with subst $x $t (EXI $vs $P) â†ª ite ($x âˆˆ $vs) (EXI $vs $P) (EXI $vs (subst $x $t $P))
with subst $x $t (EQ $e1 $e2) â†ª EQ (subst $x $t $e1) (subst $x $t $e2)
with subst $x $t (ATOM $f)    â†ª ATOM (subst $x $t $f);

// evaluation
symbol ev [a : Set] [b : Set] : El (a â¤³ b);

// ordered pairs, set equality ??
symbol opair : El (exp â¤³ exp â¤³ exp);
symbol eql_set : El (exp â¤³ exp â¤³ prd);

// operations for finding/replacing a term within an n-ary conjunction.
sequential symbol elem_conj : El (prd â¤³ prd â¤³ bool);
rule elem_conj $P ($P and $xs) â†ª âŠ¤
with elem_conj $P ($Q and $xs) â†ª elem_conj $P $xs
with elem_conj $P _          â†ª âŠ¥;

sequential symbol repl_conj : El (prd â¤³ prd â¤³ prd â¤³ prd);
rule repl_conj $Q $Q' ($Q and $xs) â†ª ($Q' and $xs)
with repl_conj $Q $Q' ($P and $xs) â†ª ($P  and (repl_conj $Q $Q' $xs))
with repl_conj _  _   $R           â†ª $R;
