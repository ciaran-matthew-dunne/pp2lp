require open Logic.U.Set Logic.U.Prop;
require open Logic.U.Arrow Logic.U.DepArrow Logic.U.Quant;
require open pp2lp.Prelude;

// ------ predicates, expressions, formulas ------
symbol idt : Set â‰” string;
symbol vrb : Set â‰” list idt;
symbol prd : Set;
symbol exp : Set;
symbol frm : Set;

// ------ primitive logical symbols --------------
injective symbol and  : El (prd â¤³ prd â¤³ prd);
injective symbol or   : El (prd â¤³ prd â¤³ prd);
injective symbol =>   : El (prd â¤³ prd â¤³ prd);
injective symbol <=>  : El (prd â¤³ prd â¤³ prd);
injective symbol not  : El (prd â¤³ prd);
injective symbol =    : El (exp â¤³ exp â¤³ prd);
injective symbol atom : El (frm â¤³ prd);
injective symbol ! : El (vrb â¤³ prd â¤³ prd);
injective symbol # : El (vrb â¤³ prd â¤³ prd);
injective symbol var : El (idt â¤³ exp);

notation =   infix left 2;
notation and infix left 2;
notation or  infix left 2;
notation =>  infix left 2;
notation <=> infix left 1;
notation not prefix 3;

// mystery quantifiers
injective symbol â™¢ : El (vrb â¤³ prd â¤³ prd);  // aka. forall
injective symbol â™¡ : El (vrb â¤³ prd â¤³ prd); // aka. forall2

symbol VRAI : El prd;
symbol FAUX : El prd;

// not equal
injective symbol != (a b : El exp) â‰” not (a = b);
notation !=  infix left 2;

// ----- Arithmetic -----------------------
// similarly for arithmetic relation symbols, why are these not in the grammar for prd?
symbol > : El (exp â¤³ exp â¤³ prd);
symbol â‰¤ : El (exp â¤³ exp â¤³ prd);
symbol < : El (exp â¤³ exp â¤³ prd);
symbol â‰ª : El (exp â¤³ exp â¤³ prd);
symbol ðŸŽ : El (exp);
symbol ðŸ : El (exp);
symbol â¨ª : El (exp â¤³ exp);
symbol + : El (exp â¤³ exp â¤³ exp);
symbol - : El (exp â¤³ exp â¤³ exp);

notation > infix 5;
notation â‰¤ infix 5;
notation < infix 5;
notation â‰ª infix 5;
notation + infix 5;
notation - infix 5;


// ------ Sequents ---------------------------
symbol seq : Set;
injective symbol âŸ : El (list prd â¤³ prd â¤³ seq);
notation âŸ infix 0;

// sequent derivations
injective symbol âœ“ : El bool â†’ El seq â†’ TYPE;
injective symbol â–· : El seq â†’ TYPE;
rule (â–· $Î£) â†ª âœ“ true $Î£;

injective symbol Thm : El prd â†’ TYPE;
rule Thm $p â†ª â–· (nil âŸ $p);


// ---- Results ------------------------------
injective symbol Res : El seq â†’ TYPE;
symbol obtain [Î£ : El seq] : Res Î£ â†’ El prd;
symbol result [Î£ : El seq] : El prd â†’ Res Î£;

rule obtain (result $P) â†ª $P;
coerce_rule coerce (Res $Î£) (El prd) $Ï â†ª obtain $Ï;

// ----- Operations on terms -----------------------
// syntactic equality on expressions and predicates.
sequential symbol == [a : Set] : El (a â¤³ a â¤³ bool);
notation == infix 5;

symbol !== [a : Set] : El (a â¤³ a â¤³ bool)
  â‰” Î» x y, !! (x == y);
notation !== infix 5;

rule ((==) [string] $x $x) â†ª true
with ((==) [string] _  _)  â†ª false;

rule FAUX == FAUX â†ª true
with VRAI == VRAI â†ª true
with (not $p) == (not $q)           â†ª ($p == $q)
with ($p1 and $p2) == ($q1 and $q2) â†ª ($p1 == $q1) && ($p2 == $q2)
with ($p1 or $p2) == ($q1 or $q2)   â†ª ($p1 == $q1) && ($p2 == $q2)
with ($p1 => $p2) == ($q1 => $q2)   â†ª ($p1 == $q1) && ($p2 == $q2)
with ($p1 <=> $p2) == ($q1 <=> $q2) â†ª ($p1 == $q1) && ($p2 == $q2)
with ($e1 = $e2) == ($f1 = $f2)     â†ª ($e1 == $f1) && ($e2 == $f2);
//with ($e1 !== $e2) == ($f1 !== $f2)   â†ª ($e1 == $f1) && ($e2 == $f2);
//with (! $P) == (! $Q) â†ª (`âˆ€ x, ($P x == $Q x))
//with (# $P) == (# $Q) â†ª (`âˆ€ x, ($P x == $Q x))
//with (â™¢ $P) == (â™¢ $Q) â†ª (`âˆ€ x, ($P x == $Q x))
//with (â™¡ $P) == (â™¡ $Q) â†ª (`âˆ€ x, ($P x == $Q x`));

// ------- free vars, substitution ----------------
symbol free [a : Set] : El (idt â¤³ a â¤³ bool);

rule free $x (var $y) â†ª ($x == $y);

rule free $x ($P and $Q)  â†ª (free $x $P) <> (free $x $Q)
with free $x ($P or $Q)   â†ª (free $x $P) <> (free $x $Q)
with free $x ($P => $Q)   â†ª (free $x $P) <> (free $x $Q)
with free $x ($P <=> $Q)  â†ª (free $x $P) <> (free $x $Q)
with free $x (not $P)     â†ª free $x $P
with free $x (! $vs $P)   â†ª (free $x $P) && !! ($x âˆˆ $vs)
with free $x (# $vs $P)   â†ª (free $x $P) && !! ($x âˆˆ $vs)
with free $x ($e1 = $e2)  â†ª (free $x $e1) <> (free $x $e2)
with free $x (atom $f)    â†ª (free $x $f)
with free $x FAUX â†ª false
with free $x VRAI â†ª false;

symbol subst [a : Set] : El (idt â¤³ exp â¤³ a â¤³ a);
//rule subst $x $t (VAR $y)     â†ª ite ($x == $y) $t (VAR $y)
//with subst $x $t (AND $P $Q)  â†ª AND (subst $x $t $P) (subst $x $t $Q)
//with subst $x $t (OR $P $Q)   â†ª OR (subst $x $t $P) (subst $x $t $Q)
//with subst $x $t (IMPL $P $Q) â†ª IMPL (subst $x $t $P) (subst $x $t $Q)
//with subst $x $t (IFF $P $Q)  â†ª IFF (subst $x $t $P) (subst $x $t $Q)
//with subst $x $t (NOT $P)     â†ª NOT (subst $x $t $P)
//with subst $x $t (ALL $vs $P) â†ª ite ($x âˆˆ $vs) (ALL $vs $P) (ALL $vs (subst $x $t $P))
//with subst $x $t (EXI $vs $P) â†ª ite ($x âˆˆ $vs) (EXI $vs $P) (EXI $vs (subst $x $t $P))
//with subst $x $t (EQ $e1 $e2) â†ª EQ (subst $x $t $e1) (subst $x $t $e2)
//with subst $x $t (ATOM $f)    â†ª ATOM (subst $x $t $f);

// evaluation
symbol ev [a : Set] [b : Set] : El (a â¤³ b);

// ordered pairs, set equality ??
symbol opair : El (exp â¤³ exp â¤³ exp);
symbol eql_set : El (exp â¤³ exp â¤³ prd);

// operations for finding/replacing a term within an n-ary conjunction.
sequential symbol elem_conj : El (prd â¤³ prd â¤³ bool);
rule elem_conj $P ($P and $xs) â†ª true
with elem_conj $P ($Q and $xs) â†ª elem_conj $P $xs
with elem_conj $P _            â†ª false;

sequential symbol repl_conj : El (prd â¤³ prd â¤³ prd â¤³ prd);
rule repl_conj $Q $Q' ($Q and $xs) â†ª ($Q' and $xs)
with repl_conj $Q $Q' ($P and $xs) â†ª ($P  and (repl_conj $Q $Q' $xs))
with repl_conj _  _   $R           â†ª $R;

 constant symbol Tactic : TYPE;

  constant symbol #admit : Tactic;
  builtin "admit" â‰” #admit;

  symbol & : Tactic â†’ Tactic â†’ Tactic;
  builtin "and" â‰” &;
  notation & infix right 10;

  constant symbol #apply [p] : El p â†’ Tactic;
  builtin "apply" â‰” #apply;

  constant symbol #assume : String â†’ Tactic;
  builtin "assume" â‰” #assume;

  constant symbol #change [p] : Prf p â†’ Tactic;
  builtin "change" â‰” #change;

  constant symbol #fail : Tactic;
  builtin "fail" â‰” #fail;

  constant symbol #generalize : Î  [a], El a â†’ Tactic;
  builtin "generalize" â‰” #generalize;

  constant symbol #have : String â†’ Prop â†’ Tactic;
  builtin "have" â‰” #have;

  constant symbol #induction : Tactic;
  builtin "induction" â‰” #induction;

  constant symbol #orelse : Tactic â†’ Tactic â†’ Tactic;
  builtin "orelse" â‰” #orelse;

  constant symbol #refine : String â†’ Tactic;
  builtin "refine" â‰” #refine;

  constant symbol #reflexivity : Tactic;
  builtin "reflexivity" â‰” #reflexivity;

  constant symbol #remove : Î  [a], Prf a â†’ Tactic;
  builtin "remove" â‰” #remove;

  constant symbol #repeat : Tactic â†’ Tactic;
  builtin "repeat" â‰” #repeat;

  constant symbol #rewrite_gen : String â†’ String â†’ Î  [p], Prf p â†’ Tactic;
  builtin "rewrite" â‰” #rewrite_gen;

  symbol #rewrite : Î  [p], Prf p â†’ Tactic â‰” @#rewrite_gen "" "";

  constant symbol #set : String â†’ Î  [a], Prf a â†’ Tactic;
  builtin "set" â‰” #set;

  constant symbol #simplify : /* Î  [a], Ï„ a â†’ */ Tactic;
  builtin "simplify" â‰” #simplify;

  constant symbol #simplify_beta : Tactic;
  builtin "simplify rule off" â‰” #simplify_beta;

  constant symbol #solve : Tactic;
  builtin "solve" â‰” #solve;

  constant symbol #symmetry : Tactic;
  builtin "symmetry" â‰” #symmetry;

  constant symbol #try : Tactic â†’ Tactic;
  builtin "try" â‰” #try;

  constant symbol #why3 : /*Ï„ (option string) â†’*/ Tactic;
  builtin "why3" â‰” #why3;
