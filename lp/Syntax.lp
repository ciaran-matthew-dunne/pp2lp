require open Logic.U.Set Logic.U.Prop;
require open Logic.U.Arrow Logic.U.DepArrow Logic.U.Quant;
require open pp2lp.Prelude;

// ------ predicates, expressions, formulas ------
symbol ð•Š : TYPE;
builtin "String" â‰” ð•Š;

symbol str : Set;
rule El str â†ª ð•Š;

symbol vrb : Set â‰” list str;
symbol prd : Set;
symbol exp : Set;
symbol idv : Set; // individuals, sets, etc.
//symbol frm : Set;

// cast an expression to a predicate.
injective symbol Î¨ : El exp â†’ El prd;
coerce_rule coerce (El exp) (El prd) $p â†ª Î¨ $p;

injective symbol Î¹ : El idv â†’ El exp;
coerce_rule coerce (El idv) (El exp) $x â†ª Î¹ $x;
coerce_rule coerce (El idv) (El prd) $x â†ª Î¨ (Î¹ $x);

// TODO.
injective symbol â€µ : El (exp â¤³ exp â¤³ exp);
notation â€µ infix left 10;

injective symbol âˆˆ : El (exp â¤³ exp â¤³ prd);
notation âˆˆ infix left 2;


// ------ primitive logical symbols --------------
injective symbol and  : El (prd â¤³ prd â¤³ prd);
injective symbol or   : El (prd â¤³ prd â¤³ prd);
injective symbol =>   : El (prd â¤³ prd â¤³ prd);
injective symbol <=>  : El (prd â¤³ prd â¤³ prd);
injective symbol not  : El (prd â¤³ prd);
injective symbol =    : El (exp â¤³ exp â¤³ prd);

notation =   infix left 2;
notation and infix left 2;
notation or  infix left 2;
notation =>  infix left 2;
notation <=> infix left 1;
notation not prefix 3;

injective symbol var : El (str â¤³ exp);
coerce_rule coerce ð•Š (El exp) $str â†ª var $str;

// quantifiers
injective symbol ! : El vrb â†’ El prd â†’ El prd;
injective symbol # : El (vrb â¤³ prd â¤³ prd);
injective symbol â™¢ : El (vrb â¤³ prd â¤³ prd);  // aka. forall
injective symbol â™¡ : El (vrb â¤³ prd â¤³ prd); // aka. forall2

symbol â‹… : El (str â¤³ list str) â‰” Î» x, cons x nil;
notation â‹… postfix 10;

assert âŠ¢ ("x" â‹…) : El (list str);

symbol â¨¾ : El (str â¤³ str â¤³ list str) â‰”
  Î» x y, cons x (cons y nil);
notation â¨¾ infix right 5;


symbol VRAI : El prd;
symbol FAUX : El prd;

// not equal
injective symbol != (a b : El exp) â‰” not (a = b);
notation !=  infix left 2;

// ordered pairs
symbol âˆ¥ : El (exp â¤³ exp â¤³ exp);
notation âˆ¥ infix left 5;

// ----- Arithmetic -----------------------
// similarly for arithmetic relation symbols, why are these not in the grammar for prd?
symbol > : El (exp â¤³ exp â¤³ prd);
symbol â‰¤ : El (exp â¤³ exp â¤³ prd);
symbol < : El (exp â¤³ exp â¤³ prd);
symbol â‰ª : El (exp â¤³ exp â¤³ prd);
symbol ðŸŽ : El (exp);
symbol ðŸ : El (exp);
symbol â¨ª : El (exp â¤³ exp);
symbol + : El (exp â¤³ exp â¤³ exp);
symbol - : El (exp â¤³ exp â¤³ exp);

notation > infix 5;
notation â‰¤ infix 5;
notation < infix 5;
notation â‰ª infix 5;
notation + infix 5;
notation - infix 5;

symbol solveur [a : Set] : El (a â¤³ a);
rule solveur (Î¨ $e) â†ª Î¨ (solveur $e);
rule solveur (Î¹ $p) â†ª (Î¹ $p);

// ------ Sequents ---------------------------
symbol seq : Set;
injective symbol âŸ : El (list prd â¤³ prd â¤³ seq);
notation âŸ infix 0;

// sequent derivations
injective symbol âœ“ : El bool â†’ El seq â†’ TYPE;
injective symbol â–· : El seq â†’ TYPE;
rule (â–· $Î£) â†ª âœ“ true $Î£;

injective symbol Thm : El prd â†’ TYPE;
rule Thm $p â†ª â–· (nil âŸ $p);


// ---- Results ------------------------------
injective symbol Res : El seq â†’ TYPE;
symbol obtain [Î£ : El seq] : Res Î£ â†’ El prd;
symbol result [Î£ : El seq] : El prd â†’ Res Î£;

rule obtain (result $P) â†ª $P;
coerce_rule coerce (Res $Î£) (El prd) $Ï â†ª obtain $Ï;

// ----- Operations on terms -----------------------
// syntactic equality on expressions and predicates.
sequential symbol == [a : Set] : El (a â¤³ a â¤³ bool);
notation == infix 5;

symbol !== [a : Set] : El (a â¤³ a â¤³ bool)
  â‰” Î» x y, !! (x == y);
notation !== infix 5;

rule ((==) [str] $x $x) â†ª true
with ((==) [str] _  _)  â†ª false;

// syntactic equality on predicates
rule FAUX == FAUX â†ª true
with VRAI == VRAI â†ª true
with (not $p) == (not $q)           â†ª ($p == $q)
with ($p1 and $p2) == ($q1 and $q2) â†ª ($p1 == $q1) && ($p2 == $q2)
with ($p1 or $p2) == ($q1 or $q2)   â†ª ($p1 == $q1) && ($p2 == $q2)
with ($p1 => $p2) == ($q1 => $q2)   â†ª ($p1 == $q1) && ($p2 == $q2)
with ($p1 <=> $p2) == ($q1 <=> $q2) â†ª ($p1 == $q1) && ($p2 == $q2)
with ($e1 = $e2) == ($f1 = $f2)     â†ª ($e1 == $f1) && ($e2 == $f2)
with (Î¨ $e1) == (Î¨ $e2)             â†ª $e1 == $e2;

//with (! $P) == (! $Q) â†ª (`âˆ€ x, ($P x == $Q x))
//with (# $P) == (# $Q) â†ª (`âˆ€ x, ($P x == $Q x))
//with (â™¢ $P) == (â™¢ $Q) â†ª (`âˆ€ x, ($P x == $Q x))
//with (â™¡ $P) == (â™¡ $Q) â†ª (`âˆ€ x, ($P x == $Q x`));

// syntactic equality on expressions
rule (var $x == var $y) â†ª ($x == $y)
with ($e1 â€µ $e2) == ($f1 â€µ $f2) â†ª ($e1 == $f1) && ($e2 == $f2)
with (Î¹ $p) == (Î¹ $p) â†ª true;

// otherwise, return false
rule _ == _ â†ª false;

// ------- free vars, substitution ----------------
sequential symbol free [a : Set] : El (str â¤³ a â¤³ bool);

 //defining `free` on predicates
rule free $x ($P and $Q)  â†ª (free $x $P) <> (free $x $Q)
with free $x ($P or $Q)   â†ª (free $x $P) <> (free $x $Q)
with free $x ($P => $Q)   â†ª (free $x $P) <> (free $x $Q)
with free $x ($P <=> $Q)  â†ª (free $x $P) <> (free $x $Q)
with free $x (not $P)     â†ª free $x $P
with free $x (! $vs $P)   â†ª (free $x $P) && !! ($x â‹¿ $vs)
with free $x (# $vs $P)   â†ª (free $x $P) && !! ($x â‹¿ $vs)
with free $x ($e1 = $e2)  â†ª (free $x $e1) <> (free $x $e2)
with free $x FAUX â†ª false
with free $x VRAI â†ª false;

rule free $x (Î¨ $e) â†ª (free $x $e)
with free $x ($e1 âˆˆ $e2) â†ª (free $x $e1) <> (free $x $e2);

// defining `free` on expressions
rule free $x (var $y) â†ª ($x == $y)
with free $x (Î¹ _) â†ª false
with free $x ($e1 â€µ $e2) â†ª (free $x $e1) <> (free $x $e2)
with free $x ($e1 âˆ¥ $e2) â†ª (free $x $e1) <> (free $x $e2);
//with free $x _ â†ª false;
//with free $x ($f â€¶ $y) â†ª (free $x $f) <> (free $x $y);

rule free $x (cons [exp] $y $ys)
  â†ª ite (var $x == $y) true (free $x $ys)
with free $x (nil)     â†ª false;

symbol subst [a : Set] : El (str â¤³ exp â¤³ a â¤³ a);

rule subst $x $t ($P and $Q)  â†ª (subst $x $t $P) and (subst $x $t $Q)
with subst $x $t ($P or $Q)   â†ª (subst $x $t $P) or (subst $x $t $Q)
with subst $x $t ($P => $Q)   â†ª (subst $x $t $P) => (subst $x $t $Q)
with subst $x $t ($P <=> $Q)  â†ª (subst $x $t $P) <=> (subst $x $t $Q)
with subst $x $t (not $P)     â†ª not (subst $x $t $P)
with subst $x $t (! $vs $P)   â†ª ite ($x â‹¿ $vs) (! $vs $P) (! $vs (subst $x $t $P))
with subst $x $t (# $vs $P)   â†ª ite ($x â‹¿ $vs) (# $vs $P) (# $vs (subst $x $t $P))
with subst $x $t ($e1 = $e2)  â†ª (subst $x $t $e1) = (subst $x $t $e2);

rule subst $x $t (var $y) â†ª ite ($x == $y) $t (var $y)
with subst $x $t (Î¨ $p)   â†ª Î¨ (subst $x $t $p)
with subst $x $t ($f â€µ $y) â†ª (subst $x $t $f) â€µ (subst $x $t $y);

symbol multisubst [a : Set] : El (vrb â¤³ list exp â¤³ a â¤³ a);
rule multisubst nil _ $t â†ª $t
with multisubst _ nil $t â†ª $t
with multisubst (cons $x $xs) (cons $e $es) $t â†ª
  multisubst $xs $es (subst $x $e $t);

// evaluation
symbol ev [a : Set] [b : Set] : El (a â¤³ b);

// ordered pairs, set equality ??
symbol eql_set : El (exp â¤³ exp â¤³ prd);

// operations for finding/replacing a term within an n-ary conjunction.
sequential symbol elem_conj : El (prd â¤³ prd â¤³ bool);
rule elem_conj $P ($P and $xs) â†ª true
with elem_conj $P ($Q and $xs) â†ª elem_conj $P $xs
with elem_conj $P _            â†ª false;

sequential symbol repl_conj : El (prd â¤³ prd â¤³ prd â¤³ prd);
rule repl_conj $Q $Q' ($Q and $xs) â†ª ($Q' and $xs)
with repl_conj $Q $Q' ($P and $xs) â†ª ($P  and (repl_conj $Q $Q' $xs))
with repl_conj _  _   $R           â†ª $R;
