require open Logic.U.Set Logic.U.Prop Logic.U.Arrow Logic.U.Quant;
require open pp2lp.Prelude;

// ------ predicates, expressions, formulas ------

symbol idt â‰” string;
symbol vrb â‰” list idt;

symbol EXP : TYPE;
symbol FRM : TYPE;

inductive PRD : TYPE â‰”
  | AND : PRD â†’ PRD â†’ PRD
  | OR  : PRD â†’ PRD â†’ PRD
  | IMPL : PRD â†’ PRD â†’ PRD
  | IFF  : PRD â†’ PRD â†’ PRD
  | NOT : PRD â†’ PRD
  | ALL : El vrb â†’ PRD â†’ PRD
  | EXI : El vrb â†’ PRD â†’ PRD
  | EQ  : EXP â†’ EXP â†’ PRD
  | ATOM : FRM â†’ PRD;

symbol prd : Set;
symbol exp : Set;
symbol frm : Set;

rule El prd â†ª PRD;
rule El exp â†ª EXP;

// inject identifiers into expressions.
injective symbol var : El (idt â¤³ exp);


// ------ primitive logical symbols --------------
injective symbol and  â‰” AND;
injective symbol or   â‰” OR;
injective symbol =>   â‰” IMPL;
injective symbol <=>  â‰” IFF;
injective symbol not  â‰” NOT;
injective symbol =    â‰” EQ;
injective symbol atom â‰” ATOM;
injective symbol ! â‰” ALL;
injective symbol # â‰” EXI;

notation =   infix left 2;
notation and infix left 2;
notation or  infix left 2;
notation =>  infix left 2;
notation <=> infix left 1;
notation not prefix 3;




// ------ Sequents ---------------------------

// sequents
symbol seq : Set;
injective symbol âŸ : El ((list prd) â¤³ prd â¤³ seq);
notation âŸ infix 0;

// sequents-as-types
symbol â–· : El seq â†’ Set;

// results
symbol âŸ¿ : El seq â†’ El prd â†’ Set;
notation âŸ¿ infix 0;

// exceptions
symbol âˆ… : Set;

// conditional
symbol â‡› : Prop â†’ Set â†’ Set;
notation â‡› infix right 0;
rule âŠ¤ â‡› $x â†ª $x
with âŠ¥ â‡› _  â†ª âˆ…;

// substitution
symbol subst_prd : El (idt â¤³ exp â¤³ prd â¤³ prd);
symbol subst_exp : El (idt â¤³ exp â¤³ exp â¤³ exp);
symbol subst_frm : El (idt â¤³ exp â¤³ frm â¤³ frm);

rule (subst_prd $x $e ($p1 and $p2)) â†ª (subst_prd $x $e $p1) and (subst_prd $x $e $p2)
with (subst_prd $x $e ($p1 or $p2)) â†ª (subst_prd $x $e $p1) or (subst_prd $x $e $p2)
with (subst_prd $x $e ($p1 => $p2)) â†ª (subst_prd $x $e $p1) => (subst_prd $x $e $p2)
with (subst_prd $x $e ($p1 <=> $p2)) â†ª (subst_prd $x $e $p1) <=> (subst_prd $x $e $p2)
with (subst_prd $x $e (not $p)) â†ª not (subst_prd $x $e $p)
with (subst_prd $x $e ($e1 = $e2)) â†ª (subst_exp $x $e $e1) = (subst_exp $x $e $e1);
//with (subst_prd $x $e (! $xs $p)) â†ª ...
//with (subst_prd $x $e (! $xs $p)) â†ª ...

// ----- Misc symbols -----------------------

// not equal
injective symbol != (a b : El exp) â‰” not (a = b);
notation !=  infix left 2;

// booleans
symbol VRAI : El prd;
symbol FAUX : El prd;

// mystery quantifiers
injective symbol forall : El (vrb â¤³ prd â¤³ prd);  // aka. â™¢
injective symbol forall2 : El (vrb â¤³ prd â¤³ prd); // aka. â™¡

// some macros for quantifiers
symbol âˆ€1 (s : String) : El (prd â¤³ prd) â‰” ! (s âˆ· nil);
symbol âˆƒ1 (s : String) : El (prd â¤³ prd) â‰” # (s âˆ· nil);
symbol â™¢1 (s : String) : El (prd â¤³ prd) â‰” forall (s âˆ· nil);
symbol â™¡1 (s : String) : El (prd â¤³ prd) â‰” forall2 (s âˆ· nil);

symbol âˆ€2 (s1 s2 : String) : El (prd â¤³ prd) â‰” ! (s1 âˆ· s2 âˆ· nil);
symbol âˆƒ2 (s1 s2 : String) : El (prd â¤³ prd) â‰” # (s1 âˆ· s2 âˆ· nil);
symbol â™¢2 (s1 s2 : String) : El (prd â¤³ prd) â‰” forall (s1 âˆ· s2 âˆ· nil);
symbol â™¡2 (s1 s2 : String) : El (prd â¤³ prd) â‰” forall2 (s1 âˆ· s2 âˆ· nil);

// arithmetic
symbol > : El (exp â¤³ exp â¤³ prd);
symbol â‰¤ : El (exp â¤³ exp â¤³ prd);
symbol < : El (exp â¤³ exp â¤³ prd);
symbol â‰ª : El (exp â¤³ exp â¤³ prd);
symbol ðŸŽ : El (exp);
symbol ðŸ : El (exp);
symbol â¨ª : El (exp â¤³ exp);
symbol + : El (exp â¤³ exp â¤³ exp);
symbol - : El (exp â¤³ exp â¤³ exp);

notation > infix 5;
notation â‰¤ infix 5;
notation < infix 5;
notation â‰ª infix 5;
notation + infix 5;
notation - infix 5;



// ----- Operations on terms -----------------------

// syntactic equality on predicates
rule FAUX â‰£ FAUX â†ª âŠ¤
with VRAI â‰£ VRAI â†ª âŠ¤
with (not $p) â‰£ (not $q)           â†ª ($p â‰£ $q)
with ($p1 and $p2) â‰£ ($q1 and $q2) â†ª ($p1 â‰£ $q1) âˆ§ ($p2 â‰£ $q2)
with ($p1 or $p2) â‰£ ($q1 or $q2)   â†ª ($p1 â‰£ $q1) âˆ§ ($p2 â‰£ $q2)
with ($p1 => $p2) â‰£ ($q1 => $q2)   â†ª ($p1 â‰£ $q1) âˆ§ ($p2 â‰£ $q2)
with ($p1 <=> $p2) â‰£ ($q1 <=> $q2) â†ª ($p1 â‰£ $q1) âˆ§ ($p2 â‰£ $q2)
with ($e1 = $e2) â‰£ ($f1 = $f2)     â†ª ($e1 â‰£ $f1) âˆ§ ($e2 â‰£ $f2)
with ($e1 != $e2) â‰£ ($f1 != $f2)   â†ª ($e1 â‰£ $f1) âˆ§ ($e2 â‰£ $f2);
//with (! $P) â‰£ (! $Q) â†ª (`âˆ€ x, ($P x â‰£ $Q x))
//with (# $P) â‰£ (# $Q) â†ª (`âˆ€ x, ($P x â‰£ $Q x))
//with (â™¢ $P) â‰£ (â™¢ $Q) â†ª (`âˆ€ x, ($P x â‰£ $Q x))
//with (â™¡ $P) â‰£ (â™¡ $Q) â†ª (`âˆ€ x, ($P x â‰£ $Q x`));

// evaluation
symbol ev [a : Set] [b : Set] : El (a â¤³ b);

// ordered pairs, set equality ??
symbol opair : El (exp â¤³ exp â¤³ exp);
symbol eql_set : El (exp â¤³ exp â¤³ prd);

sequential symbol unfold_conj : El (prd â¤³ list prd);
rule unfold_conj ($x and $xs) â†ª cons $x (unfold_conj $xs)
with unfold_conj $p           â†ª nil;

sequential symbol fold_conj : El (list prd â¤³ prd);
rule fold_conj ($x âˆ· nil) â†ª $x
with fold_conj ($x âˆ· $xs) â†ª $x and (fold_conj $xs)
with fold_conj nil        â†ª FAUX;
