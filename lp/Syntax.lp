require open Logic.U.Set Logic.U.Prop;
require open Logic.U.Arrow Logic.U.DepArrow Logic.U.Quant;
require open pp2lp.Prelude;

// ------ predicates, expressions, formulas ------
symbol idt : Set â‰” string;
symbol vrb : Set â‰” list idt;
symbol prd : Set;
symbol exp : Set;
symbol frm : Set;

// ------ primitive logical symbols --------------
injective symbol and  : El (prd â¤³ prd â¤³ prd);
injective symbol or   : El (prd â¤³ prd â¤³ prd);
injective symbol =>   : El (prd â¤³ prd â¤³ prd);
injective symbol <=>  : El (prd â¤³ prd â¤³ prd);
injective symbol not  : El (prd â¤³ prd);
injective symbol =    : El (exp â¤³ exp â¤³ prd);
injective symbol atom : El (frm â¤³ prd);
injective symbol ! : El (vrb â¤³ prd â¤³ prd);
injective symbol # : El (vrb â¤³ prd â¤³ prd);
injective symbol var : El (idt â¤³ exp);

notation =   infix left 2;
notation and infix left 2;
notation or  infix left 2;
notation =>  infix left 2;
notation <=> infix left 1;
notation not prefix 3;

// mystery quantifiers
injective symbol â™¢ : El (vrb â¤³ prd â¤³ prd);  // aka. forall
injective symbol â™¡ : El (vrb â¤³ prd â¤³ prd); // aka. forall2

symbol VRAI : El prd;
symbol FAUX : El prd;

// not equal
injective symbol != (a b : El exp) â‰” not (a = b);
notation !=  infix left 2;

// ----- Arithmetic -----------------------
// similarly for arithmetic relation symbols, why are these not in the grammar for prd?
symbol > : El (exp â¤³ exp â¤³ prd);
symbol â‰¤ : El (exp â¤³ exp â¤³ prd);
symbol < : El (exp â¤³ exp â¤³ prd);
symbol â‰ª : El (exp â¤³ exp â¤³ prd);
symbol ðŸŽ : El (exp);
symbol ðŸ : El (exp);
symbol â¨ª : El (exp â¤³ exp);
symbol + : El (exp â¤³ exp â¤³ exp);
symbol - : El (exp â¤³ exp â¤³ exp);

notation > infix 5;
notation â‰¤ infix 5;
notation < infix 5;
notation â‰ª infix 5;
notation + infix 5;
notation - infix 5;

// TODO.
// operator to apply set to obtain expression
injective symbol â€µ : El (exp â¤³ exp â¤³ prd);
notation â€µ infix 10;

// operator to apply set to obtain predicate
injective symbol â€¶ : El (exp â¤³ exp â¤³ exp);
notation â€¶ infix 10;

injective symbol âˆˆ : El (list exp â¤³ exp â¤³ prd);
notation âˆˆ infix left 2;

// ordered pairs
symbol opair : El (exp â¤³ exp â¤³ exp);

// ------ Sequents ---------------------------
symbol seq : Set;
injective symbol âŸ : El (list prd â¤³ prd â¤³ seq);
notation âŸ infix 0;

// sequent derivations
injective symbol âœ“ : El bool â†’ El seq â†’ TYPE;
injective symbol â–· : El seq â†’ TYPE;
rule (â–· $Î£) â†ª âœ“ true $Î£;

injective symbol Thm : El prd â†’ TYPE;
rule Thm $p â†ª â–· (nil âŸ $p);


// ---- Results ------------------------------
injective symbol Res : El seq â†’ TYPE;
symbol obtain [Î£ : El seq] : Res Î£ â†’ El prd;
symbol result [Î£ : El seq] : El prd â†’ Res Î£;

rule obtain (result $P) â†ª $P;
coerce_rule coerce (Res $Î£) (El prd) $Ï â†ª obtain $Ï;

// ----- Operations on terms -----------------------
// syntactic equality on expressions and predicates.
sequential symbol == [a : Set] : El (a â¤³ a â¤³ bool);
notation == infix 5;

symbol !== [a : Set] : El (a â¤³ a â¤³ bool)
  â‰” Î» x y, !! (x == y);
notation !== infix 5;

rule ((==) [string] $x $x) â†ª true
with ((==) [string] _  _)  â†ª false;

rule (var $x == var $y) â†ª ($x == $y);

rule FAUX == FAUX â†ª true
with VRAI == VRAI â†ª true
with (not $p) == (not $q)           â†ª ($p == $q)
with ($p1 and $p2) == ($q1 and $q2) â†ª ($p1 == $q1) && ($p2 == $q2)
with ($p1 or $p2) == ($q1 or $q2)   â†ª ($p1 == $q1) && ($p2 == $q2)
with ($p1 => $p2) == ($q1 => $q2)   â†ª ($p1 == $q1) && ($p2 == $q2)
with ($p1 <=> $p2) == ($q1 <=> $q2) â†ª ($p1 == $q1) && ($p2 == $q2)
with ($e1 = $e2) == ($f1 = $f2)     â†ª ($e1 == $f1) && ($e2 == $f2);
//with (! $P) == (! $Q) â†ª (`âˆ€ x, ($P x == $Q x))
//with (# $P) == (# $Q) â†ª (`âˆ€ x, ($P x == $Q x))
//with (â™¢ $P) == (â™¢ $Q) â†ª (`âˆ€ x, ($P x == $Q x))
//with (â™¡ $P) == (â™¡ $Q) â†ª (`âˆ€ x, ($P x == $Q x`));
//
rule ($e1 â€µ $e2) == ($f1 â€µ $f2) â†ª ($e1 == $f1) && ($e2 == $f2);

// ------- free vars, substitution ----------------
symbol free [a : Set] : El (idt â¤³ a â¤³ bool);

rule free $x (var $y) â†ª ($x == $y);

rule free $x ($P and $Q)  â†ª (free $x $P) <> (free $x $Q)
with free $x ($P or $Q)   â†ª (free $x $P) <> (free $x $Q)
with free $x ($P => $Q)   â†ª (free $x $P) <> (free $x $Q)
with free $x ($P <=> $Q)  â†ª (free $x $P) <> (free $x $Q)
with free $x (not $P)     â†ª free $x $P
with free $x (! $vs $P)   â†ª (free $x $P) && !! ($x â‹¿ $vs)
with free $x (# $vs $P)   â†ª (free $x $P) && !! ($x â‹¿ $vs)
with free $x ($e1 = $e2)  â†ª (free $x $e1) <> (free $x $e2)
with free $x (atom $f)    â†ª (free $x $f)
with free $x (opair $y $z) â†ª (free $x $y) <> (free $x $z)
with free $x FAUX â†ª false
with free $x VRAI â†ª false;


rule free $x ($f â€µ $y) â†ª (free $x $f) <> (free $x $y)
with free $x ($f â€¶ $y) â†ª (free $x $f) <> (free $x $y)
with free $x (cons [exp] $y $ys) â†ª ite (var $x == $y) true (free $x $ys)
with free $x (nil)     â†ª false
with free $x ($y âˆˆ $z) â†ª (free $x $y) <> (free $x $z);

symbol subst [a : Set] : El (idt â¤³ exp â¤³ a â¤³ a);
rule subst $x $t (var $y)     â†ª ite ($x == $y) $t (var $y)
with subst $x $t ($P and $Q)  â†ª (subst $x $t $P) and (subst $x $t $Q)
with subst $x $t ($P or $Q)   â†ª (subst $x $t $P) or (subst $x $t $Q)
with subst $x $t ($P => $Q)   â†ª (subst $x $t $P) => (subst $x $t $Q)
with subst $x $t ($P <=> $Q)  â†ª (subst $x $t $P) <=> (subst $x $t $Q)
with subst $x $t (not $P)     â†ª not (subst $x $t $P)
with subst $x $t (! $vs $P)   â†ª ite ($x â‹¿ $vs) (! $vs $P) (! $vs (subst $x $t $P))
with subst $x $t (# $vs $P)   â†ª ite ($x â‹¿ $vs) (# $vs $P) (# $vs (subst $x $t $P))
with subst $x $t ($e1 = $e2)  â†ª (subst $x $t $e1) = (subst $x $t $e2)
with subst $x $t (atom $f)    â†ª atom (subst $x $t $f)
with subst $x $t ($f â€µ $y) â†ª (subst $x $t $f) â€µ (subst $x $t $y);

// evaluation
symbol ev [a : Set] [b : Set] : El (a â¤³ b);

// ordered pairs, set equality ??
symbol eql_set : El (exp â¤³ exp â¤³ prd);

// operations for finding/replacing a term within an n-ary conjunction.
sequential symbol elem_conj : El (prd â¤³ prd â¤³ bool);
rule elem_conj $P ($P and $xs) â†ª true
with elem_conj $P ($Q and $xs) â†ª elem_conj $P $xs
with elem_conj $P _            â†ª false;

sequential symbol repl_conj : El (prd â¤³ prd â¤³ prd â¤³ prd);
rule repl_conj $Q $Q' ($Q and $xs) â†ª ($Q' and $xs)
with repl_conj $Q $Q' ($P and $xs) â†ª ($P  and (repl_conj $Q $Q' $xs))
with repl_conj _  _   $R           â†ª $R;
