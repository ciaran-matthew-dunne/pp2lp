require open Logic.U.Set Logic.U.Prop Logic.U.Arrow Logic.U.Quant;
require open pp2lp.Prelude;

// primitive logical symbols
injective symbol and : El (prd â¤³ prd â¤³ prd);
injective symbol or : El (prd â¤³ prd â¤³ prd);
injective symbol => : El (prd â¤³ prd â¤³ prd);
injective symbol <=> : El (prd â¤³ prd â¤³ prd);
injective symbol not : El (prd â¤³ prd);
injective symbol ! : El ((exp â¤³ prd) â¤³ prd);
injective symbol # : El ((exp â¤³ prd) â¤³ prd);
injective symbol =  : El (exp â¤³ exp â¤³ prd);
injective symbol != : El (exp â¤³ exp â¤³ prd);
injective symbol â„² : El frm â†’ El prd;

symbol VRAI  : El prd;
symbol FAUX : El prd;

notation = infix left 2;
notation != infix left 2;

notation and infix left 2;
notation or  infix left 2;
notation =>  infix left 2;
notation <=> infix left 1;
notation not       prefix 3;

notation ! quantifier;
notation # quantifier;

// weird quantifiers (?)
symbol â™¢ : El ((exp â¤³ prd) â¤³ prd);
symbol â™¡ : El ((exp â¤³ prd) â¤³ prd);

notation â™¢ quantifier;
notation â™¡ quantifier;

// syntactic equality on predicates
rule FAUX â‰ˆ FAUX â†ª âŠ¤
with VRAI â‰ˆ VRAI â†ª âŠ¤
with ($p1 and $p2) â‰ˆ ($q1 and $q2) â†ª ($p1 â‰ˆ $q1) âˆ§ ($p2 â‰ˆ $q2)
with ($p1 or $p2) â‰ˆ ($q1 or $q2)   â†ª ($p1 â‰ˆ $q1) âˆ§ ($p2 â‰ˆ $q2)
with ($p1 => $p2) â‰ˆ ($q1 => $q2)   â†ª ($p1 â‰ˆ $q1) âˆ§ ($p2 â‰ˆ $q2)
with ($p1 <=> $p2) â‰ˆ ($q1 <=> $q2) â†ª ($p1 â‰ˆ $q1) âˆ§ ($p2 â‰ˆ $q2)
with ($e1 = $e2) â‰ˆ ($f1 = $f2)   â†ª ($e1 â‰ˆ $f1) âˆ§ ($e2 â‰ˆ $f2)
with ($e1 != $e2) â‰ˆ ($f1 != $f2) â†ª ($e1 â‰ˆ $f1) âˆ§ ($e2 â‰ˆ $f2)
with (! $P) â‰ˆ (! $Q) â†ª (`âˆ€ x, ($P x â‰ˆ $Q x))
with (# $P) â‰ˆ (# $Q) â†ª (`âˆ€ x, ($P x â‰ˆ $Q x))
with (â™¢ $P) â‰ˆ (â™¢ $Q) â†ª (`âˆ€ x, ($P x â‰ˆ $Q x))
with (â™¡ $P) â‰ˆ (â™¡ $Q) â†ª (`âˆ€ x, ($P x â‰ˆ $Q x));



// arithmetic
symbol â‰¤ : El (exp â¤³ exp â¤³ prd);
symbol < : El (exp â¤³ exp â¤³ prd);
symbol â‰ª : El (exp â¤³ exp â¤³ prd);
symbol ðŸŽ : El (exp);
symbol ðŸ : El (exp);
symbol â¨ª : El (exp â¤³ exp);
symbol + : El (exp â¤³ exp â¤³ exp);
symbol - : El (exp â¤³ exp â¤³ exp);
symbol â„• : El exp;
symbol âˆˆ : El (exp â¤³ exp â¤³ prd);
symbol solveur [a : Set] : El (a â¤³ a);

notation â‰¤ infix 5;
notation < infix 5;
notation < infix 5;
notation + infix 5;
notation - infix 5;
notation âˆˆ infix 5;

// ordered pairs, set equality ??
symbol opair : El (exp â¤³ exp â¤³ exp);
symbol eql_set : El (exp â¤³ exp â¤³ prd);

symbol â­† : El (list prd â¤³ prd â¤³ prd);
notation â­† infix 5;

rule (nil â­† $p) â†ª $p
with (($q âˆ· $qs) â­† $p) â†ª $q => ($qs â­† $p);
