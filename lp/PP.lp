require Stdlib.Prop as P;
require open Stdlib.Classic;
require open pp2lp.B pp2lp.Eq;

// `Set`-level encodings for `Prd` and `Exp`.
symbol prd : Set; rule Ï„ prd â†ª Prd;
symbol exp : Set; rule Ï„ exp â†ª Exp;

inductive Hyp : TYPE â‰”
  | â¦³ : Hyp
  | âˆ· : Hyp â†’ Prd â†’ Hyp;

notation âˆ· infix 1;

symbol dans : Prd â†’ Hyp â†’ ğ”¹;
notation dans infix 1;

rule ($P dans â¦³)         â†ª false
with ($P dans ($H âˆ· $Q)) â†ª prd_eq $P $Q or ($P dans $H);

symbol Sqnt : TYPE;
symbol âŸ : Hyp â†’ Prd â†’ Sqnt; notation âŸ infix 1;
symbol â–· : Sqnt â†’ TYPE;

// boolean guard: `â‡ b` is inhabited iff `b` computes to `true`.
symbol â‡ (b : ğ”¹) â‰” Ï€ (istrue b);

symbol âŠ© â‰” Î» H P, â–· (H âŸ P);
notation âŠ© infix 1;

symbol contient : Prd â†’ Prd â†’ ğ”¹;
notation contient infix 1;

// search for X in the leaves of a conjunction tree.
rule (($Qs âˆ§ $Q) contient $X) â†ª prd_eq $X $Q or ($Qs contient $X)
with (_ contient $X) â†ª false;

// remove the first occurrence of X in clause C (right-to-left search).
symbol retirer : Prd â†’ Prd â†’ Prd;
rule retirer $X ($Cs âˆ§ $Q)
  â†ª if (prd_eq $X $Q) [prd] $Cs
      (if (prd_eq $X $Cs) [prd] $Q ((retirer $X $Cs) âˆ§ $Q));

symbol prop : Prd â†’ Prop;
rule prop (Â¬ $P)    â†ª (P.Â¬) (prop $P)
with prop ($P âˆ§ $Q) â†ª (P.âˆ§) (prop $P) (prop $Q)
with prop ($P âˆ¨ $Q) â†ª (P.âˆ¨) (prop $P) (prop $Q)
with prop ($P â‡’ $Q) â†ª (P.â‡’) (prop $P) (prop $Q)
with prop ($P â‡” $Q) â†ª (P.â‡”) (prop $P) (prop $Q);

symbol props : Hyp â†’ Prop;
rule props (â¦³)       â†ª âŠ¤
with props ($H âˆ· $P) â†ª (P.âˆ§) (props $H) (prop $P);

rule â–· ($H âŸ $P) â†ª Ï€ (props $H) â†’ Ï€ (prop $P);

// induction principle on hyp-lists
symbol Hyp_ind (M : Hyp â†’ Prop)
  : Ï€ (M â¦³) â†’ (Î  H, Ï€ (M H) â†’ Î  Q, Ï€ (M (H âˆ· Q))) â†’ Î  H, Ï€ (M H) â‰”
begin
  assume M base step;
  induction
  { refine base }
  { assume H ih Q; refine step H ih Q }
end;


// ---- conjunction ----------------
opaque symbol AND1 [H P Q R]
  : (H âŠ© Â¬ Q â‡’ R) â†’ (H âŠ© Â¬ P â‡’ R) â†’ (H âŠ© Â¬ (P âˆ§ Q) â‡’ R) â‰”
begin
  assume H P Q R; simplify;
  assume one two h npq;
  apply âˆ¨â‚‘ (em (prop P))
  { assume hp; refine one h (Î» hq, npq (âˆ§áµ¢ hp hq)) }
  { assume hnp; refine two h hnp }
end;

opaque symbol AND2 [H P Q]
  : (H âŠ© P â‡’ Â¬ Q) â†’ (H âŠ© Â¬ (P âˆ§ Q)) â‰”
begin
  assume H P Q; simplify;
  assume one h pq;
  refine one h (âˆ§â‚‘â‚ pq) (âˆ§â‚‘â‚‚ pq)
end;

opaque symbol AND3 [H P Q R]
  : (H âŠ© P â‡’ (Q â‡’ R)) â†’ (H âŠ© (P âˆ§ Q) â‡’ R) â‰”
begin
  assume H P Q R; simplify;
  assume one h pq;
  refine one h (âˆ§â‚‘â‚ pq) (âˆ§â‚‘â‚‚ pq)
end;


opaque symbol AND4 [H P Q]
  : (H âŠ© Q) â†’ (H âŠ© P) â†’ (H âŠ© P âˆ§ Q) â‰”
begin
  assume H P Q; simplify;
  assume one two h;
  refine âˆ§áµ¢ (two h) (one h)
end;

// AND5 â€” propositional version.
opaque symbol AND5p [H P Q A B R]
  : (Ï€ (prop (P âˆ§ Q)) â†’ Ï€ ((prop (retirer (A â‡’ B) (P âˆ§ Q))) P.âˆ§ (prop (A â‡’ B))))
  â†’ (Ï€ (prop (retirer (A â‡’ B) (P âˆ§ Q))) â†’ Ï€ (prop A))
  â†’ (H âŠ© retirer (A â‡’ B) (P âˆ§ Q) âˆ§ B â‡’ R)
  â†’ (H âŠ© (P âˆ§ Q) â‡’ R) â‰”
begin
  assume H P Q A B R split extract_a sub;
  simplify; assume h pq;
  have s : Ï€ ((prop (retirer (A â‡’ B) (P âˆ§ Q))) P.âˆ§ (prop (A â‡’ B)))
    { refine split pq };
  set rem â‰” P.âˆ§â‚‘â‚ s;
  set imp â‰” P.âˆ§â‚‘â‚‚ s;
  have ha : Ï€ (prop A) { refine extract_a rem };
  have hb : Ï€ (prop B) { refine imp ha };
  refine sub h (P.âˆ§áµ¢ rem hb)
end;

// AND5 â€” computational wrapper.
symbol AND5 [H P Q A B R]
  : â‡ ((P âˆ§ Q) contient (A â‡’ B))
  â†’ â‡ (retirer (A â‡’ B) (P âˆ§ Q) contient A)
  â†’ (H âŠ© retirer (A â‡’ B) (P âˆ§ Q) âˆ§ B â‡’ R)
  â†’ (H âŠ© (P âˆ§ Q) â‡’ R);

// ---- disjunction ----------------
opaque symbol OR1 [H P Q R]
  : (H âŠ© Â¬ P â‡’ (Â¬ Q â‡’ R)) â†’ (H âŠ© Â¬ (P âˆ¨ Q) â‡’ R) â‰”
begin
  assume H P Q R; simplify; assume one h npq;
  refine one h (Î» hp, npq (âˆ¨áµ¢â‚ hp)) (Î» hq, npq (âˆ¨áµ¢â‚‚ hq))
end;

opaque symbol OR2 [H P Q]
  : (H âŠ© Â¬ Q) â†’ (H âŠ© Â¬ P) â†’ (H âŠ© Â¬ (P âˆ¨ Q)) â‰”
begin
  assume H P Q; simplify; assume one two h pq;
  apply âˆ¨â‚‘ pq
  { assume hp; refine two h hp }
  { assume hq; refine one h hq }
end;

opaque symbol OR3 [H P Q R]
  : (H âŠ© Q â‡’ R) â†’ (H âŠ© P â‡’ R) â†’ (H âŠ© (P âˆ¨ Q) â‡’ R) â‰”
begin
  assume H P Q R; simplify; assume one two h pq;
  apply âˆ¨â‚‘ pq
  { assume hp; refine two h hp }
  { assume hq; refine one h hq }
end;

opaque symbol OR4 [H P Q]
  : (H âŠ© Â¬ P â‡’ Q) â†’ (H âŠ© P âˆ¨ Q) â‰”
begin
  assume H P Q; simplify; assume one h;
  apply âˆ¨â‚‘ (em (prop P))
  { assume hp; refine âˆ¨áµ¢â‚ hp }
  { assume hnp; refine âˆ¨áµ¢â‚‚ (one h hnp) }
end;

// ---- implication ----------------
opaque symbol IMP1 [H P Q R]
  : (H âŠ© P â‡’ ((Â¬ Q) â‡’ R)) â†’ (H âŠ© (Â¬ (P â‡’ Q)) â‡’ R) â‰”
begin
  assume H P Q R; simplify; assume one h npq;
  apply âˆ¨â‚‘ (em (prop Q))
  { assume hq; refine âŠ¥â‚‘ (npq (Î» _, hq)) }
  { assume hnq;
    apply âˆ¨â‚‘ (em (prop P))
    { assume hp; refine one h hp hnq }
    { assume hnp; refine âŠ¥â‚‘ (npq (Î» hp, âŠ¥â‚‘ (hnp hp))) } }
end;

opaque symbol IMP2 [H P Q]
  : (H âŠ© Â¬ Q) â†’ (H âŠ© P) â†’ (H âŠ© Â¬ (P â‡’ Q)) â‰”
begin
  assume H P Q; simplify; assume one two h p;
  refine (one h) (p (two h))
end;

opaque symbol IMP3 [H P Q R]
  : (H âŠ© Q â‡’ R) â†’ (H âŠ© (Â¬ P) â‡’ R) â†’ (H âŠ© (P â‡’ Q) â‡’ R) â‰”
begin
  assume H P Q R; simplify; assume one two h pq;
  apply âˆ¨â‚‘ (em (prop P))
  { assume hp; refine one h (pq hp) }
  { assume hnp; refine two h hnp }
end;

opaque symbol IMP4 [H P Q]
  : ((H âˆ· P) âŠ© Q) â†’ (H âŠ© P â‡’ Q) â‰”
begin
  assume H P Q; assume hp h p;
  refine hp (âˆ§áµ¢ h p)
end;

// IMP5 â€” propositional version.
opaque symbol IMP5p [H P Q]
  : (Ï€ (props H) â†’ Ï€ (prop P)) â†’ (H âŠ© Q) â†’ (H âŠ© P â‡’ Q) â‰”
begin
  assume H P Q lookup one; simplify; assume h p;
  refine one h
end;

// IMP5 â€” computational wrapper.
symbol IMP5 [H P Q]
  : â‡ (P dans H) â†’ (H âŠ© Q) â†’ (H âŠ© P â‡’ Q);

// ---- equivalence ----------------
opaque symbol EQV1 [H P Q R]
  : (H âŠ© P â‡’ (Â¬ Q â‡’ R)) â†’ (H âŠ© Â¬ P â‡’ (Q â‡’ R))
  â†’ (H âŠ© Â¬ (P â‡” Q) â‡’ R) â‰”
begin
  assume H P Q R; simplify;
  assume one two h npq;
  apply âˆ¨â‚‘ (em (prop P))
  { assume hp;
    refine one h hp (Î» hq, npq (âˆ§áµ¢ (Î» _, hq) (Î» _, hp))) }
  { assume hnp;
    apply âˆ¨â‚‘ (em (prop Q))
    { assume hq; refine two h hnp hq }
    { assume hnq; refine one h (Â¬Â¬â‚‘ _ (Î» np, npq (âˆ§áµ¢ (Î» hp, âŠ¥â‚‘ (np hp)) (Î» hq, âŠ¥â‚‘ (hnq hq))))) hnq } }
end;

opaque symbol EQV2 [H P Q]
  : (H âŠ© P â‡’ Â¬ Q) â†’ (H âŠ© Â¬ Q â‡’ P) â†’ (H âŠ© Â¬ (P â‡” Q)) â‰”
begin
  assume H P Q; simplify; assume one two h pq;
  set pq1 â‰” âˆ§â‚‘â‚ pq; set pq2 â‰” âˆ§â‚‘â‚‚ pq;
  apply âˆ¨â‚‘ (em (prop Q))
  { assume hq; refine one h (pq2 hq) hq }
  { assume hnq; refine one h (two h hnq) (pq1 (two h hnq)) }
end;

opaque symbol EQV3 [H P Q R]
  : (H âŠ© P â‡’ (Q â‡’ R)) â†’ (H âŠ© Â¬ P â‡’ (Â¬ Q â‡’ R))
  â†’ (H âŠ© (P â‡” Q) â‡’ R) â‰”
begin
  assume H P Q R; simplify; assume one two h pq;
  set pq1 â‰” âˆ§â‚‘â‚ pq; set pq2 â‰” âˆ§â‚‘â‚‚ pq;
  apply âˆ¨â‚‘ (em (prop P))
  { assume hp; refine one h hp (pq1 hp) }
  { assume hnp; refine two h hnp (Î» hq, âŠ¥â‚‘ (hnp (pq2 hq))) }
end;

opaque symbol EQV4 [H P Q]
  : (H âŠ© P â‡’ Q) â†’ (H âŠ© Q â‡’ P) â†’ (H âŠ© P â‡” Q) â‰”
begin
  assume H P Q; simplify; assume one two h;
  refine âˆ§áµ¢ (one h) (two h)
end;

// ---- negation ----------------
opaque symbol NOT1 [H P R]
  : (H âŠ© P â‡’ R) â†’ (H âŠ© Â¬ Â¬ P â‡’ R) â‰”
begin
  assume H P R; simplify; assume one h nnp;
  refine one h (Â¬Â¬â‚‘ _ nnp)
end;

opaque symbol NOT2 [H P]
  : (H âŠ© P) â†’ (H âŠ© Â¬ Â¬ P) â‰”
begin
  assume H P; simplify; assume one h np;
  refine np (one h)
end;

// ---- 'axioms' --------
symbol AXM1 [H P Q] : â‡ (Â¬ P dans H) â†’ (H âŠ© P â‡’ Q);
symbol AXM2 [H P Q] : â‡ (P dans H) â†’ (H âŠ© Â¬ P â‡’ Q);
symbol AXM3 [H P] : â‡ (P dans H) â†’ (H âŠ© P);
symbol AXM4 [H P R] : â‡ (R dans H) â†’ (H âŠ© P â‡’ R);
symbol AXM5 [H P Q R] : â‡ (Â¬ Q dans H) â†’ (H âŠ© P â‡’ (Q â‡’ R));
symbol AXM6 [H P Q R] : â‡ (Q dans H) â†’ (H âŠ© P â‡’ (Â¬ Q â‡’ R));
symbol AXM8 [H C R] : â‡ (C contient R) â†’ (H âŠ© C â‡’ R);
