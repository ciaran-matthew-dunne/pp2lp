require open
  Stdlib.Bool
  Stdlib.String;

// datatype for variable-lists.
inductive Var : TYPE â‰”
  | id : String â†’ Var
  | â¨¾ : Var â†’ Var â†’ Var;
notation â¨¾ infix right 5;

// datatypes for predicates, expressions, and sets:
inductive Prd : TYPE â‰”
  | Â¬ : Prd â†’ Prd
  | âˆ§ : Prd â†’ Prd â†’ Prd
  | âˆ¨ : Prd â†’ Prd â†’ Prd
  | â‡’ : Prd â†’ Prd â†’ Prd
  | â‡” : Prd â†’ Prd â†’ Prd
  | = : Exp â†’ Exp â†’ Prd
  | âˆˆ : Exp â†’ Exp â†’ Prd
  | âˆ€ : Var â†’ Prd â†’ Prd
  | âˆƒ : Var â†’ Prd â†’ Prd
  | â™¢ : Var â†’ Prd â†’ Prd
  | â™¡ : Var â†’ Prd â†’ Prd
with Exp : TYPE â‰”
  | #var : Var â†’ Exp
  | â†¦ : Exp â†’ Exp â†’ Exp
  | Ã— : Exp â†’ Exp â†’ Exp
  | ğ’« : Exp â†’ Exp
  | big : Exp
  | choice : Exp â†’ Exp
  | comp : Var â†’ Prd â†’ Exp;

// `prf p` is the type of proofs of `p`
symbol prf : Prd â†’ TYPE;
symbol â–· â‰” prf; notation â–· prefix 5;

// infix notation. precedences given by pp-spec (Â§6.1).
// higher number = tighter binding in lambdapi.
// pp-spec order (looseâ†’tight): â‡’(0) â‡”(1) âˆ§âˆ¨(2) Â¬(3) =(4) âˆˆ(5)
notation â†¦ infix 5;
notation Ã— infix 5;
notation â‡’ infix left 6;
notation â‡” infix left 7;
notation âˆ§ infix left 8;
notation âˆ¨ infix left 8;
notation Â¬ prefix 9;
notation = infix left 10;
notation âˆˆ infix left 15;

// shorthand: string to expression via variable.
symbol #id â‰” Î» str, #var (id str);

// coerce a string to a varaible.
coerce_rule coerce String Var $str â†ª id $str;
/// coerce a string to an expression.
coerce_rule coerce String Exp $str â†ª #var (id $str);
// coerce a varaible to an expression.
coerce_rule coerce Var Exp $x â†ª #var $x;


compute
  âˆ€ "x" ("x" = "x");

// define disequality.
symbol != â‰” Î» E F, Â¬ (E = F);
notation != infix 20;

// define âŠ† inclusion.
symbol âŠ† â‰” Î» s t, s âˆˆ ğ’« t;
notation âŠ† infix 10;

// define âŠ‚ inclusion.
symbol âŠ‚ â‰” Î» s t, (s âŠ† t) âˆ§ (s != t);
notation âŠ‚ infix 10;

// syntactic equality, see `Eq.lp`.
sequential symbol var_eq : Var â†’ Var â†’ ğ”¹;
sequential symbol exp_eq : Exp â†’ Exp â†’ ğ”¹;
sequential symbol prd_eq : Prd â†’ Prd â†’ ğ”¹;

// sum type for (Exp + Prd)
inductive Trm : TYPE â‰”
  | #exp : Exp â†’ Trm
  | #prd : Prd â†’ Trm;

// syntactic equality.
sequential symbol == : Trm â†’ Trm â†’ ğ”¹; notation == infix 10;
// define by dispatching on constructor.
rule (#exp $E == #exp $F) â†ª exp_eq $E $F
with (#prd $P == #prd $Q) â†ª prd_eq $P $Q
with (_ == _) â†ª false;

// non-free. see NonFree.lp
symbol nf : Var â†’ Trm â†’ ğ”¹;
symbol pnf : Var â†’ Prd â†’ ğ”¹;
symbol enf : Var â†’ Exp â†’ ğ”¹;

rule nf $x (#prd $P) â†ª pnf $x $P
with nf $x (#exp $E) â†ª enf $x $E;

// substitution. see Subst.lp
symbol sub : Var â†’ Exp â†’ Trm â†’ Trm;
symbol psub : Var â†’ Exp â†’ Prd â†’ Prd;
symbol esub : Var â†’ Exp â†’ Exp â†’ Exp;

rule sub $x $E (#prd $P) â†ª #prd (psub $x $E $P)
with sub $x $E (#exp $F) â†ª #exp (esub $x $E $F);

// boolean-guarded expression.
symbol ?exp : Exp â†’ ğ”¹ â†’ Exp;
rule ?exp $E true â†ª $E;

// boolean-guarded predicate.
symbol ?prd : Prd â†’ ğ”¹ â†’ Prd;
rule ?prd $P true â†ª $P;
