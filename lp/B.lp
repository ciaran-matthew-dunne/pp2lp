require open
  Stdlib.Prop
  Stdlib.String
  Stdlib.Z;

// datatype for variable-lists.
inductive Var : TYPE â‰”
  | id : String â†’ Var
  | â¨¾ : Var â†’ Var â†’ Var;
notation â¨¾ infix right 5;

// datatypes for predicates, expressions, and sets:
inductive Prd : TYPE â‰”
  | âˆ§ : Prd â†’ Prd â†’ Prd
  | â‡’ : Prd â†’ Prd â†’ Prd
  | Â¬ : Prd â†’ Prd
  | âˆ€ : Var â†’ Prd â†’ Prd
  | = : Exp â†’ Exp â†’ Prd
  | âˆˆ : Exp â†’ Exp â†’ Prd
with Exp : TYPE â‰”
  | #var : Var â†’ Exp
  | â†¦ : Exp â†’ Exp â†’ Exp
  | Ã— : Exp â†’ Exp â†’ Exp
  | ğ’« : Exp â†’ Exp
  | big : Exp
  | choice : Exp â†’ Exp
  | comp : Var â†’ Prd â†’ Exp;

symbol #id â‰” Î» str, #var (id str);

// coercion rules for variables and sets:
coerce_rule coerce Var Exp $x â†ª #var $x;

// infix notation for predicates:
notation Â¬ prefix 10;
notation âˆ§ infix left 9;
notation â‡’ infix left 8;

// logical disjunction and equivalence.
symbol âˆ¨ â‰” Î» p q, Â¬ p â‡’ q;
symbol â‡” â‰” Î» p q, (p â‡’ q) âˆ§ (q â‡’ p);
notation âˆ¨ infix left 9;
notation â‡” infix left 7;

// infix notation for maplets and products.
notation â†¦ infix 5;
notation Ã— infix 5;

// infix notation for membership and equality.
notation âˆˆ infix left 15;
notation = infix 5;


sequential symbol bSet : Exp â†’ ğ”¹;
rule bSet ($E â†¦ $F) â†ª false
with bSet (choice $E) â†ª bSet $E
with bSet ($E Ã— $F) â†ª (bSet $E) and (bSet $F)
with bSet (ğ’« $E) â†ª bSet $E
with bSet (comp $x $P) â†ª true
with bSet big â†ª true;


// define disequality.
symbol != â‰” Î» E F, Â¬ (E = F);
notation != infix 20;

// define âŠ† inclusion.
symbol âŠ† â‰” Î» s t, s âˆˆ ğ’« t;
notation âŠ† infix 10;

// define âŠ‚ inclusion.
symbol âŠ‚ â‰” Î» s t, (s âŠ† t) âˆ§ (s != t);
notation âŠ‚ infix 10;

// syntactic equality:
sequential symbol var_eq : Var â†’ Var â†’ ğ”¹;
sequential symbol exp_eq : Exp â†’ Exp â†’ ğ”¹;
sequential symbol prd_eq : Prd â†’ Prd â†’ ğ”¹;

rule var_eq $x $x â†ª true
with var_eq _ _ â†ª false;

// core expressions.
rule exp_eq (#var $x) (#var $y) â†ª var_eq $x $y
with exp_eq ($E â†¦ $F) ($G â†¦ $H)
  â†ª (exp_eq $E $G) and (exp_eq $F $H)
with exp_eq (choice $s) (choice $t) â†ª exp_eq $s $t
// set expressions.
with exp_eq ($s Ã— $t) ($u Ã— $v)
  â†ª (exp_eq $s $u) and (exp_eq $t $v)
with exp_eq (ğ’« $s) (ğ’« $t) â†ª exp_eq $s $t
with exp_eq (big) (big) â†ª true
with exp_eq (comp $x $P) (comp $y $Q)
  â†ª (var_eq $x $y) and (prd_eq $P $Q)
with exp_eq _ _ â†ª false;


// defined on predicates thus:
rule prd_eq ($p âˆ§ $q) ($r âˆ§ $s)
  â†ª (prd_eq $p $r) and (prd_eq $q $s)
with prd_eq ($p â‡’ $q) ($r â‡’ $s)
  â†ª (prd_eq $p $r) and (prd_eq $q $s)
with prd_eq (Â¬ $p) (Â¬ $q)
  â†ª (prd_eq $p $q)
with prd_eq (âˆ€ $x $p) (âˆ€ $y $q)
  â†ª (var_eq $x $y) and (prd_eq $p $q)
with prd_eq ($e = $f) ($g = $h)
  â†ª (exp_eq $e $g) and (exp_eq $f $h)
with prd_eq ($e âˆˆ $s) ($f âˆˆ $t)
  â†ª (exp_eq $e $f) and (exp_eq $s $t)
with prd_eq _ _ â†ª false;
// end.


// datatype for B-formulas: i.e., either expr or pred.
inductive Frm : TYPE â‰”
  | #exp : Exp â†’ Frm
  | #prd : Prd â†’ Frm;

// syntactic equality on formulas.
sequential symbol == : Frm â†’ Frm â†’ ğ”¹;
notation == infix 10;
rule (#exp $E == #exp $F) â†ª exp_eq $E $F
with (#prd $P == #prd $Q) â†ª prd_eq $P $Q
with (_ == _) â†ª false;

// coercion rules for Exp -> Frm, Prd -> Frm.
coerce_rule coerce Exp Frm $e â†ª #exp $e;
coerce_rule coerce Prd Frm $p â†ª #prd $p;

// boolean-guarded expression.
symbol ?exp : Exp â†’ ğ”¹ â†’ Exp;
rule ?exp $E true â†ª $E;

// boolean-guarded predicate.
symbol ?prd : Prd â†’ ğ”¹ â†’ Prd;
rule ?prd $P true â†ª $P;

// non-free. see NonFree.lp
symbol nf : Var â†’ Frm â†’ ğ”¹;
symbol pnf : Var â†’ Prd â†’ ğ”¹;
symbol enf : Var â†’ Exp â†’ ğ”¹;

rule nf $x (#prd $P) â†ª pnf $x $P
with nf $x (#exp $E) â†ª enf $x $E;

// substitution. see Subst.lp
symbol sub : Var â†’ Exp â†’ Frm â†’ Frm;
symbol psub : Var â†’ Exp â†’ Prd â†’ Prd;
symbol esub : Var â†’ Exp â†’ Exp â†’ Exp;

rule sub $x $E (#prd $P) â†ª #prd (psub $x $E $P)
with sub $x $E (#exp $F) â†ª #exp (esub $x $E $F);

// datatype for B-types.
inductive bTyp : TYPE â‰”
  | super : Exp â†’ bTyp
  | typ : Exp â†’ bTyp
  | âˆ— : bTyp â†’ bTyp â†’ bTyp
  | â„™ : bTyp â†’ bTyp
  | iden : String â†’ bTyp;

// infix notation for type-level product.
notation âˆ— infix right 10;

// datatype for B-type-predicates.
inductive bTypPrd : TYPE â‰”
  | check : Prd â†’ bTypPrd
  | ty_eq : bTyp â†’ bTyp â†’ bTypPrd;


// `prf p` is the type of proofs of `p`
constant symbol prf : Prd â†’ TYPE;
symbol â–· â‰” prf; notation â–· prefix 5;

// `j : judge p` iff `j` derives the typing-predicate `p`.
constant symbol judge : bTypPrd â†’ TYPE;

// `j : âœ“ p` iff `j` derives `check p`.
symbol âœ“ (p : Prd) : TYPE â‰” judge (check p);

// `j : t â‰£ t'` iff `j` derives `ty_eq t t'`.
symbol â‰£ (t t' : bTyp) : TYPE â‰” judge (ty_eq t t');
notation â‰£ infix 5;


symbol symm [U T] : (U â‰£ T) â†’ (T â‰£ U);

symbol given : Exp â†’ TYPE;

symbol T1 [P Q : Prd]
  : âœ“ P â†’ âœ“ Q â†’ âœ“ (P âˆ§ Q);

symbol T2 [P Q : Prd]
  : âœ“ P â†’ âœ“ Q â†’ âœ“ (P â‡’ Q);

symbol T3 [P : Prd]
  : âœ“ P â†’ âœ“ (Â¬ P);

symbol T4 [x : Var] [s : Exp] [P : Prd]
  : (â–· (x âˆˆ s) â†’ âœ“ P) â†’ âœ“ (âˆ€ x (x âˆˆ s â‡’ P));

symbol T5 [x y : Var] [s t : Exp] [P : Prd]
  : âœ“ (âˆ€ x (x âˆˆ s â‡’ âˆ€ y (y âˆˆ t â‡’ P)))
  â†’ âœ“ (âˆ€ (x â¨¾ y) ((x â†¦ y) âˆˆ (s Ã— t) â‡’ P));

symbol T6 [x : Var] [P Q R : Prd]
  : âœ“ (âˆ€ x (P â‡’ Q âˆ§ R))
  â†’ âœ“ (âˆ€ x (P âˆ§ Q â‡’ R));

symbol T7 [E F : Exp]
  : (typ E â‰£ typ F) â†’ âœ“ (E = F);

symbol T8 [E s : Exp]
  : (typ E â‰£ super s) â†’ âœ“ (E âˆˆ s);

symbol T8' [s t : Exp]
  : (super s â‰£ super t) â†’ âœ“ (s âŠ† t);

symbol T9 [x : Var] [s : Exp] [U : bTyp]
  : â–· (x âˆˆ s) â†’ (super s â‰£ U) â†’ (typ x â‰£ U);

symbol T10 [E F : Exp] [U : bTyp]
  : (typ E âˆ— typ F â‰£ U) â†’ (typ (E â†¦ F) â‰£ U);

symbol T11 [s : Exp] [U : bTyp]
  : (super s â‰£ U) â†’ (typ (choice s) â‰£ U);

symbol T12 [s : Exp] [U : bTyp]
  : (â„™ (super s) â‰£ U) â†’ (typ s â‰£ U);

symbol T13 [x : Var] [s : Exp] [U : bTyp]
  : â–· (x âˆˆ s)
  â†’ (super s â‰£ â„™ U)
  â†’ (super x â‰£ U);

symbol T13' [x : Var] [s : Exp] [U : bTyp]
  : â–· (x âˆˆ s)
  â†’ (â„™ U â‰£ super s)
  â†’ (U â‰£ super x)
  â‰” Î» h1 h2, symm (T13 h1 (symm h2));

symbol T14 [s t : Exp] [U : bTyp]
  : (super s âˆ— super t â‰£ U)
  â†’ (super (s Ã— t) â‰£ U);

symbol T15 [s : Exp] [U : bTyp]
  : (â„™ (super s) â‰£ U)
  â†’ (super (ğ’« s) â‰£ U);

symbol T15' [s : Exp] [U : bTyp]
  : (U â‰£ â„™ (super s))
  â†’ (U â‰£ super (ğ’« s))
  â‰” Î» h, symm (T15 (symm h));

symbol T16 [x : Var] [s : Exp] [P : Prd] [U : bTyp]
  : âœ“ (âˆ€ x (x âˆˆ s â‡’ P))
  â†’ (super s â‰£ U)
  â†’ (super (comp x (x âˆˆ s âˆ§ P)) â‰£ U);

symbol T17 [I : String] [U : bTyp]
  : given (#id I)
  â†’ (iden I â‰£ U)
  â†’ (super (#id I) â‰£ U);

symbol T17' [I : String] [U : bTyp]
  (h1 : given (#id I))
  (h2 : U â‰£ iden I)
  : (U â‰£ super (#id I))
  â‰” symm (T17 h1 (symm h2));

symbol T18 [s : Exp] [U : bTyp]
  : (super s â‰£ â„™ U)
  â†’ (super (choice s) â‰£ U);

symbol T19 [T U : bTyp]
  : (T â‰£ U)
  â†’ (â„™ T â‰£ â„™ U);

symbol T20 [T U V W : bTyp]
  : (T â‰£ U)
  â†’ (V â‰£ W)
  â†’ (T âˆ— V â‰£ U âˆ— W);

symbol T21 [I : String]
  : given (#id I)
  â†’ (iden I â‰£ iden I);

// example of a type-checking derivation.
symbol tc_example
  (h : given (#id "s"))
  :
  let a : Var â‰” id "a" in
  let b : Var â‰” id "b" in
  let x : Var â‰” id "x" in
  let y : Var â‰” id "y" in
  let s : Exp â‰” #id "s" in
  âœ“ (âˆ€ (a â¨¾ b) (
    ((a â†¦ b) âˆˆ ((ğ’« s) Ã— (ğ’« s)))
    â‡’ (comp x (x âˆˆ s âˆ§ (x âˆˆ a âˆ§ x âˆˆ b)) âŠ† s))
  )
  â‰”
  begin
    assume h;
    apply T5;
    apply T4; assume a;
    apply T4; assume b;
    apply T8';
    apply T17' h;
    apply T16
    {
      apply T4; assume x;
      apply T1
      {
        apply T8; apply T13' a;
        apply T15'; apply T19;
        apply T17' h; apply T9 x;
        apply T17 h; apply T21 h;
      } {
        apply T8; apply T13' b;
        apply T15'; apply T19;
        apply T17' h; apply T9 x;
        apply T17 h; apply T21 h;
      }
    }{
      apply T17 h;
      apply T21 h;
    }
  end;

type tc_example;
