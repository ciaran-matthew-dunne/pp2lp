require open
  Stdlib.Prop
  Stdlib.String
  Stdlib.Z;

inductive bVar : TYPE â‰”
  | IDEN : String â†’ bVar
  | CONS : bVar â†’ bVar â†’ bVar;
inductive bPrd : TYPE â‰”
  | AND : bPrd â†’ bPrd â†’ bPrd
  | IMP : bPrd â†’ bPrd â†’ bPrd
  | NOT : bPrd â†’ bPrd
  | ALL : bVar â†’ bPrd â†’ bPrd
  | PSUB : bVar â†’ bExp â†’ bPrd â†’ bPrd
  | EQ : bExp â†’ bExp â†’ bPrd
  | MEM : bExp â†’ bSet â†’ bPrd
with bExp : TYPE â‰”
  | VAR : bVar â†’ bExp
  | ESUB : bVar â†’ bExp â†’ bExp â†’ bExp
  | PAIR : bExp â†’ bExp â†’ bExp
  | CHOICE : bSet â†’ bExp
  | SET : bSet â†’ bExp
with bSet : TYPE â‰”
  | PROD : bSet â†’ bSet â†’ bSet
  | POW : bSet â†’ bSet
  | BIG : bSet
  | COMP : bVar â†’ bPrd â†’ bSet;

inductive bTyp : TYPE â‰”
  | SUPER : bSet â†’ bTyp
  | TY_EXP : bExp â†’ bTyp
  | TY_PROD : bTyp â†’ bTyp â†’ bTyp
  | TY_POW : bTyp â†’ bTyp
  | TY_IDEN : String â†’ bTyp;


inductive bTypPrd : TYPE â‰”
  | CHECK : bPrd â†’ bTypPrd
  | TY_EQ : bTyp â†’ bTyp â†’ bTypPrd;

constant symbol judge : bTypPrd â†’ TYPE;
symbol âœ“ (p : bPrd) : TYPE â‰” judge (CHECK p);
symbol â‰£ (t t' : bTyp) : TYPE â‰” judge (TY_EQ t t');

symbol T1 [p q] : âœ“ p â†’ âœ“ q â†’ âœ“ (AND p q);
symbol T2 [p q] : âœ“ p â†’ âœ“ q â†’ âœ“ (IMP p q);
symbol T3 [p] : âœ“ p â†’ âœ“ (NOT p);





symbol bprd : bPrd â†’ Prop;
rule bprd (AND $p $q)      â†ª bprd $p âˆ§ bprd $q
with bprd (IMP $p $q)      â†ª bprd $p â‡’ bprd $q
with bprd (NOT $p)         â†ª Â¬ (bprd $p);

symbol bset : bSet â†’ Set;
symbol bexp [a] : bExp â†’ Ï„ a;

symbol bexp_ty (ty : String â†’ Set) : bExp â†’ Set;

symbol bexp_tm [a]
  (ty : String â†’ Set) (tm : Î  s : String, Ï„ (ty s))
  : bExp â†’ Ï„ a;

rule bexp_aux $ty $tm (VAR (IDEN $s)) â†ª $Î¼ $s;

// Abstract propositions for non-propositional constructors.
constant symbol eq_  : bExp â†’ bExp â†’ Prop;
constant symbol mem_ : bExp â†’ bSet â†’ Prop;
constant symbol all_ : bVar â†’ Prop â†’ Prop;
constant symbol psub_ : bVar â†’ bExp â†’ Prop â†’ Prop;


symbol Prf : bPrd â†’ TYPE;
rule Prf $p â†ª Ï€ (bprd     $p);

inductive Hyp : TYPE â‰”
  | Prd : bPrd â†’ Hyp
  | HCONS : Hyp â†’ Hyp â†’ Hyp;

inductive Seq : TYPE â‰”
  SEQ : Hyp â†’ bPrd â†’ Seq;

symbol BR_1 [p] : (Prf p â†’ Prf p) â‰”
  begin
    assume p h;
    refine h;
  end;

//symbol BR_2 [p]
symbol BR3 [p] (h1 : Prf p) : Prf p
  â‰” BR_1 h1;

symbol BR4 [p q] :
  Prf p â†’ (Prf p â†’ Prf q) â†’ Prf q â‰”
  begin
    assume p q h1 h2;
    refine h2 h1;
    print;
  end;

symbol RULE_1 [p q] :
  Prf p â†’ Prf q â†’ Prf (AND p q);
//// ----- logic. ----------
//symbol all : (bExp â†’ Prop) â†’ Prop;
//notation all quantifier;
//symbol eq : bExp â†’ bExp â†’ Prop;

//// ----- bSet theory -----
//constant symbol mem : bExp â†’ bSet â†’ Prop;
//symbol âˆˆ â‰” mem; notation âˆˆ infix 10;

//constant symbol Collect : (bExp â†’ Prop) â†’ bSet â†’ bSet;

//constant symbol Pow : bSet â†’ bSet;
//symbol ğ’« â‰” Pow;

//constant symbol choice : bSet â†’ bExp;
//constant symbol BIG : bSet;

//// coerce a bSet to an bExpression.
//constant symbol !bSet : bSet â†’ bExp;


//// ----- pairing and cartesian product -----
//constant symbol pair : bExp â†’ bExp â†’ bExp;
//constant symbol prod : bSet â†’ bSet â†’ bSet;
//symbol â¨¾ â‰” pair; notation â¨¾ infix right 5;
//symbol Ã— â‰” prod; notation Ã— infix right 5;

//// ----- axioms ------------------------------
//symbol bSet1 [E F s t] :
//  Ï€ ((E â¨¾ F) âˆˆ (s Ã— t) â‡” (E âˆˆ s âˆ§ F âˆˆ t));

//symbol bSet2 [s t] :
//  Ï€ (!bSet s âˆˆ ğ’« t â‡” `all x, (x âˆˆ s â‡’ x âˆˆ t));

//symbol bSet3 [E s P] :
//  Ï€ (E âˆˆ Collect P s â‡” (E âˆˆ s âˆ§ P E));

//symbol bSet4 [E s P] :
//  Ï€ (E âˆˆ Collect P s â‡” (E âˆˆ s âˆ§ P E));



////type bSet;
////type (â¤³);
