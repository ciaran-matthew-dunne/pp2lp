require open Logic.U.Set Logic.U.Prop Logic.U.Arrow;

symbol bool : Set;
rule El bool â†ª Prop;

injective symbol list : Set â†’ Set;
symbol nil [a : Set] : El (list a);
symbol âˆ· [a : Set] : El (a â¤³ list a â¤³ list a);
notation âˆ· infix right 5;

sequential symbol elem [a : Set] : El (a â¤³ list a â¤³ bool);
rule (elem $x nil)        â†ª âŠ¥
with (elem $x ($x âˆ· $xs)) â†ª âŠ¤
with (elem $x (_  âˆ· $ys)) â†ª (elem $x $ys);

symbol â‰ˆ [a : Set] : El (a â¤³ a â¤³ bool);
notation â‰ˆ infix right 5;

// #################
// 3. Syntax
// #################
symbol String : TYPE;
builtin "String" â‰” String;

symbol idt : Set;
//rule El idt â†ª String;

symbol vrb : Set â‰” list idt;
symbol prd : Set;
symbol exp : Set;


symbol subst : El (idt â¤³ exp â¤³ prd);

symbol âˆ€ : El (vrb â¤³ prd â¤³ prd);
symbol âˆƒ : El (vrb â¤³ prd â¤³ prd);
symbol = : El (exp â¤³ exp â¤³ prd);
symbol != : El (exp â¤³ exp â¤³ prd);

symbol frm : Set;
injective symbol atom : El frm â†’ El prd;
injective symbol âˆ§ : El (prd â¤³ prd â¤³ prd);
injective symbol âˆ¨ : El (prd â¤³ prd â¤³ prd);
injective symbol â‡’ : El (prd â¤³ prd â¤³ prd);
injective symbol â‡” : El (prd â¤³ prd â¤³ prd);
injective symbol Â¬ : El (prd â¤³ prd);

notation âˆ§ infix left 2;
notation âˆ¨ infix left 2;
notation â‡’ infix left 2;
notation â‡” infix left 1;
notation Â¬ prefix 3;

symbol â™¢ : El (vrb â¤³ prd â¤³ prd);
symbol â™¡ : El (vrb â¤³ prd â¤³ prd);

symbol â‰¤ : El (exp â¤³ exp â¤³ prd); notation â‰¤ infix 5;
symbol < : El (exp â¤³ exp â¤³ prd); notation < infix 5;
symbol â‰ª : El (exp â¤³ exp â¤³ prd); notation < infix 5;

symbol ðŸŽ : El (exp);
symbol ðŸ : El (exp);
symbol â¨ª : El (exp â¤³ exp);
symbol + : El (exp â¤³ exp â¤³ exp); notation + infix 5;
symbol - : El (exp â¤³ exp â¤³ exp); notation - infix 5;

symbol solveur [a : Set] : El (a â¤³ a);

symbol â„• : El exp;
symbol âˆˆ : El (exp â¤³ exp â¤³ prd); notation âˆˆ infix 5;




// ## sequents
symbol sequent : Set;
injective symbol âŸ : El (list prd â¤³ prd â¤³ sequent);
notation âŸ infix 0;



injective symbol âœ“ : El sequent â†’ TYPE;

symbol thm (p : El prd) : TYPE â‰” âœ“ (nil âŸ p);

// Boolean constants (implied from rules)
symbol TRUE : El prd;
symbol FALSE : El prd;

// #################
// 5.1. Conjunction
// #################
symbol AND1 [H : El (list prd)] [P Q R : El prd] :
  âœ“ (H âŸ Â¬ Q â‡’ R) â†’
  âœ“ (H âŸ Â¬ P â‡’ R) â†’
  âœ“ (H âŸ Â¬ (P âˆ§ Q) â‡’ R);

symbol AND2 [H : El (list prd)] [P Q : El prd] :
  âœ“ (H âŸ P â‡’ Â¬ Q) â†’
  âœ“ (H âŸ Â¬ (P âˆ§ Q));

symbol AND3 [H : El (list prd)] [P Q R : El prd] :
  âœ“ (H âŸ P â‡’ (Q â‡’ R)) â†’
  âœ“ (H âŸ (P âˆ§ Q) â‡’ R);

symbol AND4 [H : El (list prd)] [P Q : El prd] :
  âœ“ (H âŸ Q) â†’ // H âŠ¢ Q is the second antecedent
  âœ“ (H âŸ P) â†’ // H âŠ¢ P is the first antecedent
  âœ“ (H âŸ (P âˆ§ Q));

// This rule seems to involve pattern matching within a conjunction,
// and a substitution-like operation that is not directly captured by
// the current primitives.
symbol AND5 [H : El (list prd)] [P Q R A B : El prd] :
  // AntÃ©cÃ©dents: "P âˆ§ Â· Â· Â· Contient A", "H âŠ¢ P âˆ§ Â· Â· Â· âˆ§ (A â‡’ B) âˆ§ Â· Â· Â· â‡’ R"
  // ConsÃ©quent: "H âŠ¢ P âˆ§ Â· Â· Â· âˆ§ B âˆ§ Â· Â· Â· â‡’ R"
  // Requires a more sophisticated pattern matching and replacement mechanism.
  // Stub for now.
  TYPE;
// #################
// 5.2. Disjunction
// #################
symbol OR1 [H : El (list prd)] [P Q R : El prd] :
  âœ“ (H âŸ Â¬ P â‡’ (Â¬ Q â‡’ R)) â†’
  âœ“ (H âŸ Â¬ (P âˆ¨ Q) â‡’ R);

symbol OR2 [H : El (list prd)] [P Q : El prd] :
  âœ“ (H âŸ Â¬ Q) â†’
  âœ“ (H âŸ Â¬ P) â†’
  âœ“ (H âŸ Â¬ (P âˆ¨ Q));

symbol OR3 [H : El (list prd)] [P Q R : El prd] :
  âœ“ (H âŸ Q â‡’ R) â†’
  âœ“ (H âŸ P â‡’ R) â†’
  âœ“ (H âŸ (P âˆ¨ Q) â‡’ R);

symbol OR4 [H : El (list prd)] [P Q : El prd] :
  âœ“ (H âŸ Â¬ P â‡’ Q) â†’
  âœ“ (H âŸ (P âˆ¨ Q));

// #################
// 5.3. Implication
// #################

symbol IMP1 [H : El (list prd)] [P Q R : El prd] :
  âœ“ (H âŸ P â‡’ (Â¬ Q â‡’ R)) â†’
  âœ“ (H âŸ Â¬ (P â‡’ Q) â‡’ R);

symbol IMP2 [H : El (list prd)] [P Q : El prd] :
  âœ“ (H âŸ Â¬ Q) â†’
  âœ“ (H âŸ P) â†’ // This is "H âŠ¢ P" in the antecedent
  âœ“ (H âŸ Â¬ (P â‡’ Q));

symbol IMP3 [H : El (list prd)] [P Q R : El prd] :
  âœ“ (H âŸ Q â‡’ R) â†’
  âœ“ (H âŸ Â¬ P â‡’ R) â†’
  âœ“ (H âŸ (P â‡’ Q) â‡’ R);

symbol IMP4 [H : El (list prd)] [P Q : El prd] :
  âœ“ (P âˆ· H âŸ Q) â†’ âœ“ (H âŸ P â‡’ Q);

symbol IMP5 [H : El (list prd)] [P Q : El prd] :
  Prf (elem P H) â†’ // Side condition: "P est dans H"
  âœ“ (H âŸ Q) â†’
  âœ“ (H âŸ P â‡’ Q);

// from (H,P âŸ Q) â‡€ R and (H âŸ P â‡’ Q)
// infer (H âŸ P â‡’ R)
// This rule has a 'RÃ©sultat' (Result) column, which is not directly representable
// in the current syntax. It implies a transformation or a return value from the proof rule.
symbol IMP4' [H : El (list prd)] [P Q R S : El prd] :
  // AntÃ©cÃ©dents: "(H,P âŠ¢ Q) â‡ R"
  // ConsÃ©quent: "H âŠ¢ P â‡’ Q"
  // RÃ©sultat: "P â‡’ R"
  // This rule requires understanding of the 'â‡' operator and 'RÃ©sultat' column.
  TYPE;

// #################
// 5.4. Equivalence
// #################
symbol EQV1 [H : El (list prd)] [P Q R : El prd] :
  âœ“ (H âŸ P â‡’ (Â¬ Q â‡’ R)) â†’
  âœ“ (H âŸ Â¬ P â‡’ (Q â‡’ R)) â†’
  âœ“ (H âŸ Â¬ (P â‡” Q) â‡’ R);

symbol EQV2 [H : El (list prd)] [P Q : El prd] :
  âœ“ (H âŸ P â‡’ Â¬ Q) â†’
  âœ“ (H âŸ Â¬ Q â‡’ P) â†’
  âœ“ (H âŸ Â¬ (P â‡” Q));

symbol EQV3 [H : El (list prd)] [P Q R : El prd] :
  âœ“ (H âŸ P â‡’ (Q â‡’ R)) â†’
  âœ“ (H âŸ Â¬ P â‡’ (Â¬ Q â‡’ R)) â†’
  âœ“ (H âŸ (P â‡” Q) â‡’ R);

symbol EQV4 [H : El (list prd)] [P Q : El prd] :
  âœ“ (H âŸ P â‡’ Q) â†’
  âœ“ (H âŸ Q â‡’ P) â†’
  âœ“ (H âŸ (P â‡” Q));

// #################
// 5.5. Negation
// #################
symbol NOT1 [H : El (list prd)] [P R : El prd] :
  âœ“ (H âŸ P â‡’ R) â†’
  âœ“ (H âŸ Â¬ Â¬ P â‡’ R);

symbol NOT2 [H : El (list prd)] [P : El prd] : // R is not present in the ConsÃ©quent of NOT2
  âœ“ (H âŸ P) â†’
  âœ“ (H âŸ Â¬ Â¬ P); // The source defines H âŠ¢ Â¬Â¬P, not H âŠ¢ Â¬Â¬P â‡’ R.

// #################
// 5.6. Axioms
// #################
symbol AXM1 [H : El (list prd)] [P Q : El prd] :
  Prf (elem (Â¬ P) H) â†’
  âœ“ (H âŸ P â‡’ Q);

symbol AXM2 [H : El (list prd)] [P Q : El prd] :
  Prf (elem P H) â†’
  âœ“ (H âŸ Â¬ P â‡’ Q);

symbol AXM3 [H : El (list prd)] [P : El prd] :
  Prf (elem P H) â†’
  âœ“ (H âŸ P);

symbol AXM4 [H : El (list prd)] [P R : El prd] :
  Prf (elem R H) â†’
  âœ“ (H âŸ P â‡’ R);

symbol AXM5 [H : El (list prd)] [P Q R : El prd] :
  Prf (elem (Â¬ Q) H) â†’
  âœ“ (H âŸ P â‡’ (Q â‡’ R));

symbol AXM6 [H : El (list prd)] [P Q R : El prd] :
  Prf (elem Q H) â†’
  âœ“ (H âŸ P â‡’ (Â¬ Q â‡’ R));

symbol AXM7 [H : El (list prd)] [P : El prd] :
  âœ“ (H âŸ P â‡’ P);

// This rule seems to involve pattern matching and substitution within a conjunction,
// similar to AND5.
symbol AXM8 [H : El (list prd)] [P R : El prd] :
  // AntÃ©cÃ©dents: "P âˆ§ Â· Â· Â· contient R"
  // ConsÃ©quent: "H âŠ¢ P âˆ§ Â· Â· Â· â‡’ R"
  // This rule implies some kind of simplification or reduction within a conjunction.
  TYPE;

// This rule involves existential quantification and substitution not directly expressible.
symbol AXM9 [H : El (list prd)] [R Q : El prd] :
  // AntÃ©cÃ©dents: "âˆ€ x Â· Â¬ ( VRAI âˆ§ P ) est dans H", "On a E tel que [x := E] P = R"
  // ConsÃ©quent: "H âŠ¢ R â‡’ Q"
  // This rule appears to be about existential instantiation or a form of it.
  TYPE;

// #############################
// 5.7. Universal quantification
// #############################
sequential symbol distinct : El (idt â¤³ idt â¤³ bool);
rule distinct $x $x â†ª âŠ¥
with distinct $x _ â†ª âŠ¤ ;

symbol ? (x : El idt) : El vrb â‰” x âˆ· nil;
symbol â¨¾ (x y : El idt) : El vrb â‰” x âˆ· y âˆ· nil;
notation â¨¾ infix right 5;

symbol ALL1 [x y : El idt] [H : El (list prd)] [P R : El prd] :
  Prf (distinct x y) â†’
  âœ“ (H âŸ Â¬ (âˆ€ (x â¨¾ y) P) â‡’ R ) â†’
  âœ“ (H âŸ Â¬ (âˆ€ (? x) (âˆ€ (? y) P)) â‡’ R );

symbol ALL2 [x y : El idt] [H : El (list prd)] [P : El prd] :
  Prf (distinct x y) â†’
  âœ“ (H âŸ Â¬ (âˆ€ (x â¨¾ y) P) ) â†’
  âœ“ (H âŸ Â¬ (âˆ€ (? x) (âˆ€ (? y) P)));

symbol ALL3 [x y : El idt] [H : El (list prd)] [P R : El prd] :
  Prf (distinct x y) â†’
  âœ“ (H âŸ (âˆ€ (x â¨¾ y) P) â‡’ R ) â†’
  âœ“ (H âŸ (âˆ€ (? x) (âˆ€ (? y) P)) â‡’ R );

symbol ALL4 [x y : El idt] [H : El (list prd)] [P : El prd] :
  Prf (distinct x y) â†’
  âœ“ (H âŸ âˆ€ (x â¨¾ y) P) â†’
  âœ“ (H âŸ âˆ€ (? x) (âˆ€ (? y) P));

// This rule involves "x non libre dans R" (x not free in R) and potentially variable capture.
// A more robust mechanism for free variables and substitution is needed.
symbol ALL5 [x : El idt] [H : El (list prd)] [P R : El prd] :
  // Side condition: "x non libre dans R"
  // We'll need a mechanism for checking free variables.
  TYPE;
  // Side condition for the second ALL5 rule with different antecedents
  // "x est libre dans R", "y n'est libre ni dans P ni dans R", "S est le rÃ©sultat de la substitution [x := y] P"
  // This requires a more complex rule for substitution and free variable checking.
  // TYPE; // Placeholder for the second ALL5 rule variant.

symbol ALL6 [x : El idt] [H : El (list prd)] [P : El prd] :
  âœ“ (H âŸ (âˆ€ (? x) P) â‡’ FALSE) â†’
  âœ“ (H âŸ Â¬ (âˆ€ (? x) P));

// These rules (ALL7, ALL7', ALL8, ALL8', ALL9, ALL9') use a 'â‡' operator
// and a 'RÃ©sultat' column, indicating a more complex proof transformation or
// a result of applying the rule. The 'â™¢ x' notation is not directly defined
// but likely relates to existential quantification or a special form of it.
symbol ALL7 [x : El idt] [H : El (list prd)] [P Q R : El prd] :
  // First variant: "x non libre dans H"
  // AntÃ©cÃ©dents: "( H âŠ¢ P ) â‡ R", "H âŠ¢ ( â™¢ x Â· R ) â‡’ Q"
  // ConsÃ©quent: "H âŠ¢ ( âˆ€ x Â· P ) â‡’ Q"
  TYPE;
  // Second variant: "x est libre dans H", "y n'est libre ni dans A ni dans H", "P est le rÃ©sultat de la substitution [x := y] A"
  // AntÃ©cÃ©dents: "( H âŠ¢ P ) â‡ R", "H âŠ¢ ( â™¢ x Â· R ) â‡’ Q"
  // ConsÃ©quent: "H âŠ¢ ( âˆ€ x Â· A ) â‡’ Q"
  // TYPE;

symbol ALL7_prime [x : El idt] [H : El (list prd)] [P Q R S A : El prd] :
  // First variant: "x non libre dans H"
  // AntÃ©cÃ©dents: "( H âŠ¢ P ) â‡ R", "( H âŠ¢ ( â™¢ x Â· R ) â‡’ Q ) â‡ S"
  // ConsÃ©quent: "H âŠ¢ ( âˆ€ x Â· P ) â‡’ Q"
  // RÃ©sultat: "S"
  TYPE;
  // Second variant: "x est libre dans H", "y n'est libre ni dans A ni dans H", "P est le rÃ©sultat de la substitution [x := y] A"
  // AntÃ©cÃ©dents: "( H âŠ¢ P ) â‡ R", "( H âŠ¢ ( â™¢ x Â· R ) â‡’ Q ) â‡ S"
  // ConsÃ©quent: "H âŠ¢ ( âˆ€ x Â· A ) â‡’ Q"
  // RÃ©sultat: "S"
  // TYPE;


symbol ALL8 [x : El idt] [H : El (list prd)] [P R : El prd] :
  // First variant: "x non libre dans H"
  // AntÃ©cÃ©dents: "H âŠ¢ P"
  // ConsÃ©quent: "H âŠ¢ âˆ€ x Â· P"
  TYPE;
  // Second variant: "x est libre dans H", "y n'est libre ni dans P ni dans H", "R est le rÃ©sultat de la substitution [x := y] P"
  // AntÃ©cÃ©dents: "H âŠ¢ R"
  // ConsÃ©quent: "H âŠ¢ âˆ€ x Â· P"
  // TYPE;

symbol ALL8_prime [x y : El idt] [H : El (list prd)] [P Q R : El prd] :
  // First variant: "x non libre dans H"
  // AntÃ©cÃ©dents: "( H âŠ¢ P) â‡ Q"
  // ConsÃ©quent: "H âŠ¢ âˆ€ x Â· P"
  // RÃ©sultat: "âˆ€ x Â· Q"
  TYPE;
  // Second variant: "x est libre dans H", "y n'est libre ni dans P ni dans H", "R est le rÃ©sultat de la substitution [x := y] P"
  // AntÃ©cÃ©dents: "( H âŠ¢ R) â‡ Q"
  // ConsÃ©quent: "H âŠ¢ âˆ€ x Â· P"
  // RÃ©sultat: "âˆ€ y Â· Q"
  // TYPE;

symbol ALL9 [x : El idt] [H : El (list prd)] [T Q : El prd] :
  // The 'â™¡ x Â· T' notation is not defined, but might be related to 'forall2' or a specialized universal quantifier.
  âœ“ (T âˆ· H âŸ Q) â†’ // H, ( âˆ€ x Â· T ) âŠ¢ Q
  âœ“ (H âŸ (âˆ€ (? x) T) â‡’ Q); // The symbol 'â™¡' in the antecedent corresponds to 'forall2' in the ASCII table, which is 'âˆ€ x'
  // It seems 'â™¡' is equivalent to 'âˆ€' for simple variable binding.
  // Assuming 'â™¡' is just another notation for 'âˆ€' as suggested by the ASCII table.

symbol ALL9_prime [x : El idt] [H : El (list prd)] [P Q R : El prd] :
  // AntÃ©cÃ©dents: "( H, ( âˆ€ x Â· P ) âŠ¢ Q ) â‡ R"
  // ConsÃ©quent: "H âŠ¢ ( âˆ€ x Â· P ) â‡’ Q"
  // RÃ©sultat: "( âˆ€ x Â· P ) â‡’ R"
  // Requires understanding of 'â‡' and 'RÃ©sultat'.
  TYPE;

// #############################
// 5.8. Existential quantification
// #############################
// The 'âˆƒ' symbol is assumed based on context and common logic.
// The rules for existential quantification often mirror universal quantification rules for negated forms.

symbol XST1 [x y : El idt] [H : El (list prd)] [P R : El prd] :
  Prf (distinct x y) â†’
  âœ“ (H âŸ Â¬ (âˆƒ (x â¨¾ y) P) â‡’ R ) â†’
  âœ“ (H âŸ Â¬ (âˆƒ (? x) (âˆƒ (? y) P)) â‡’ R );

symbol XST2 [x y : El idt] [H : El (list prd)] [P : El prd] :
  Prf (distinct x y) â†’
  âœ“ (H âŸ Â¬ (âˆƒ (x â¨¾ y) P) ) â†’
  âœ“ (H âŸ Â¬ (âˆƒ (? x) (âˆƒ (? y) P)));

symbol XST3 [x y : El idt] [H : El (list prd)] [P R : El prd] :
  Prf (distinct x y) â†’
  âœ“ (H âŸ (âˆƒ (x â¨¾ y) P) â‡’ R ) â†’
  âœ“ (H âŸ (âˆƒ (? x) (âˆƒ (? y) P)) â‡’ R );

symbol XST4 [x y : El idt] [H : El (list prd)] [P : El prd] :
  Prf (distinct x y) â†’
  âœ“ (H âŸ âˆƒ (x â¨¾ y) P) â†’
  âœ“ (H âŸ âˆƒ (? x) (âˆƒ (? y) P));

symbol XST5 [x : El idt] [H : El (list prd)] [P R : El prd] :
  âœ“ (H âŸ (âˆ€ (? x) Â¬ P) â‡’ R) â†’
  âœ“ (H âŸ Â¬ (âˆƒ (? x) P) â‡’ R);

symbol XST51 [x : El idt] [H : El (list prd)] [P R : El prd] :
  âœ“ (H âŸ (âˆ€ (? x) P) â‡’ R) â†’
  âœ“ (H âŸ Â¬ (âˆƒ (? x) Â¬ P) â‡’ R);

symbol XST6 [x : El idt] [H : El (list prd)] [P : El prd] :
  âœ“ (H âŸ âˆ€ (? x) Â¬ P) â†’
  âœ“ (H âŸ Â¬ (âˆƒ (? x) P));

symbol XST61 [x : El idt] [H : El (list prd)] [P : El prd] :
  âœ“ (H âŸ âˆ€ (? x) P) â†’
  âœ“ (H âŸ Â¬ (âˆƒ (? x) Â¬ P));

// Similar to ALL5, involves free variables and substitution.
symbol XST7 [x : El idt] [H : El (list prd)] [P R Q : El prd] :
  // First variant: "x non libre dans R"
  // AntÃ©cÃ©dents: "H âŠ¢ âˆ€ x Â· ( P â‡’ R )"
  // ConsÃ©quent: "H âŠ¢ ( âˆƒ x Â· P ) â‡’ R"
  TYPE;
  // Second variant: "x est libre dans R", "y n'est libre ni dans P ni dans R", "Q est le rÃ©sultat de la substitution [x := y] P"
  // AntÃ©cÃ©dents: "H âŠ¢ âˆ€ y Â· ( Q â‡’ R )"
  // ConsÃ©quent: "H âŠ¢ ( âˆƒ x Â· P ) â‡’ R"
  // TYPE;

// These rules involve the 'â‡' operator and possibly existential discharge.
symbol XST8 [x y : El idt] [H : El (list prd)] [P R A : El prd] :
  // First variant: "x non libre dans H"
  // AntÃ©cÃ©dents: "( H âŠ¢ Â¬ P ) â‡ R", "H âŠ¢ ( âˆ€ x Â· R ) â‡’ FAUX"
  // ConsÃ©quent: "H âŠ¢ âˆƒ x Â· P"
  TYPE;
  // Second variant: "x est libre dans H", "y n'est libre ni dans A ni dans H", "P est le rÃ©sultat de la substitution [x := y] A"
  // AntÃ©cÃ©dents: "( H âŠ¢ Â¬ P ) â‡ R", "H âŠ¢ ( âˆ€ x Â· R ) â‡’ FAUX"
  // ConsÃ©quent: "H âŠ¢ ( âˆƒ x Â· A )"
  // TYPE;

// #################
// 5.9. Vrai et Faux (True and False)
// #################
symbol VR1 [H : El (list prd)] [R : El prd] :
  âœ“ (H âŸ Â¬ TRUE â‡’ R);

symbol VR2 [H : El (list prd)] :
  âœ“ (H âŸ FALSE) â†’
  âœ“ (H âŸ Â¬ TRUE);

symbol VR3 [H : El (list prd)] [R : El prd] :
  âœ“ (H âŸ R) â†’
  âœ“ (H âŸ TRUE â‡’ R);

symbol VR4 [H : El (list prd)] :
  âœ“ (H âŸ TRUE);

symbol FX1 [H : El (list prd)] [R : El prd] :
  âœ“ (H âŸ R) â†’
  âœ“ (H âŸ Â¬ FALSE â‡’ R);

symbol FX2 [H : El (list prd)] :
  âœ“ (H âŸ Â¬ FALSE);

symbol FX3 [H : El (list prd)] [R : El prd] :
  âœ“ (H âŸ FALSE â‡’ R);

// #################
// 5.10. RÃ¨gles STOP
// #################
symbol STOP [H : El (list prd)] [P : El prd] :
  // Side condition: "P n'est pas le prÃ©dicat FAUX"
  âœ“ (H âŸ Â¬ P â‡’ FALSE) â†’
  âœ“ (H âŸ P);

// This rule has a 'RÃ©sultat' column.
symbol STOP_prime [H : El (list prd)] [P : El prd] :
  // AntÃ©cÃ©dents: "H âŠ¢ P"
  // ConsÃ©quent: "P" (This consequent format is unusual for sequents, suggesting P itself is the result of applying the rule)
  // RÃ©sultat: "P"
  TYPE;

// #################
// 5.11. RÃ¨gle INS (Instantiation)
// #################
symbol INS [H : El (list prd)] [Q1 Q2 Qn : El prd] : // Q1, Q2, ..., Qn are determined by "DÃ©termination des instanciations"
  // Side condition: "DÃ©termination des instanciations Q1, Q2, . . ., Qn"
  // This implies some form of meta-level computation or an external instantiation mechanism.
  //âœ“ (H âŸ Q1 â‡’ (Q2 â‡’ ... â‡’ (Qn â‡’ FALSE) ...)) â†’
  //âœ“ (H âŸ FALSE);
  TYPE;
// #################
// 5.12. Normalisation
// #################
// These rules heavily rely on "non libre dans" (not free in), substitution,
// and the 'â™¢' operator (which likely corresponds to 'exists' or a specific type of 'forall2' from the ASCII table).
// Given the complexity of free variable checking, substitution, and the 'â™¢' symbol (which is represented as 'forall2' in the ASCII table but sometimes used for existential quantifiers by convention or specific systems),
// these rules will be stubs.

symbol NRM1 [x : El idt] [H : El (list prd)] [P S : El prd] :
  // Side condition: "x non libre dans P"
  âœ“ (H âŸ P â‡’ S) â†’
  âœ“ (H âŸ (âˆ€ (? x) P) â‡’ S); // Assuming â™¢ x is âˆ€ x based on the ASCII table
  // However, the NRM rules seem to be about pushing quantifiers through implications,
  // where 'â™¢' often refers to existential (e.g., 'exists x') or a general 'forall' form that can be re-arranged.
  // I will use 'âˆ€' for 'â™¢' based on the ASCII table provided.
  // The 'â™¢' symbol is shown as 'forall2' in the ASCII table, which maps to 'âˆ€'.
  // However, the behavior of some NRM rules, especially with conjunctions (NRM7),
  // suggests 'â™¢' might act like an existential quantifier in certain contexts (distributing over conjunctions).
  // For consistency with the provided table, I'll use âˆ€ here.
  // If 'â™¢' means something else (like existential quantification 'âˆƒ'), the symbol definition for it needs to be explicit.
  //TYPE; // Stub due to 'non libre dans' side condition.

symbol NRM2 [x : El idt] [H : El (list prd)] [P Q S : El prd] :
  // Side condition: "x non libre dans P"
  TYPE; // Stub due to side condition and 'â™¢' interpretation.

symbol NRM3 [x : El idt] [H : El (list prd)] [P Q S : El prd] :
  // Side conditions: "x non libre dans Q", "Q n'est pas le prÃ©dicat FAUX"
  TYPE; // Stub due to side conditions and complex antecedent structure.

symbol NRM4 [x : El idt] [H : El (list prd)] [P Q R S : El prd] :
  // Side condition: "x non libre dans Q"
  TYPE; // Stub due to side condition and nested implication with 'â™¢'.

symbol NRM5 [x : El idt] [H : El (list prd)] [P Q R S : El prd] :
  TYPE; // Stub due to 'â™¢' interpretation and complex conjunction/implication.

symbol NRM6 [x : El idt] [H : El (list prd)] [P Q R S : El prd] :
  TYPE; // Stub due to 'â™¢' interpretation and complex antecedent structure.

symbol NRM7 [x : El idt] [H : El (list prd)] [P Q S : El prd] :
  TYPE; // Stub due to 'â™¢' interpretation and nested conjunction/implication.

symbol NRM8 [x y : El idt] [H : El (list prd)] [Q S K : El prd] :
  // First variant: "x et y sont distincts"
  TYPE; // Stub due to 'â™¢' interpretation and nested quantifiers.
  // Second variant: "x et y ne sont pas distinctes", "z est distincte de x et de y", "K est le rÃ©sultat de la substitution [y := z] Q"
  // TYPE; // Stub.

symbol NRM9 [x y : El idt] [H : El (list prd)] [P Q S K : El prd] :
  // First variant: "x et y sont distincts", "y non libre dans P"
  TYPE; // Stub due to side conditions and 'â™¢' interpretation.
  // Second variant: "x et y ne sont pas distinctes ou y est libre dans P", "z est distincte de x et non libre dans P et dans Q", "K est le rÃ©sultat de la substitution [y := z] Q"
  // TYPE; // Stub.

symbol NRM10 [x : El idt] [H : El (list prd)] [P Q R : El prd] :
  TYPE; // Stub due to 'â™¢' interpretation.

symbol NRM11 [x : El idt] [H : El (list prd)] [P R : El prd] :
  TYPE; // Stub due to 'â™¢' interpretation and VRAI (TRUE).

symbol NRM12 [x : El idt] [H : El (list prd)] [P Q R : El prd] :
  TYPE; // Stub due to 'â™¢' interpretation.

symbol NRM13 [x : El idt] [H : El (list prd)] [P Q R : El prd] :
  TYPE; // Stub due to 'â™¢' interpretation.

symbol NRM14 [x : El idt] [H : El (list prd)] [P R : El prd] :
  TYPE; // Stub due to 'â™¢' interpretation and VRAI.

symbol NRM15 [x : El idt] [H : El (list prd)] [P R : El prd] :
  TYPE; // Stub due to 'â™¢' interpretation and VRAI.

symbol NRM16 [x : El idt] [H : El (list prd)] [P Q : El prd] :
  Prf (elem (âˆ€ (? x) P) H) â†’ // "âˆ€ x Â· P est dans H"
  âœ“ (H âŸ (âˆ€ (? x) P) â‡’ Q);

// These rules involve existential instantiation and substitution, which are not directly supported.
symbol NRM17 [x y : El idt] [H : El (list prd)] [P Q R E : El prd] :
  // Side conditions: "âˆ€ x Â· Â¬ ( VRAI âˆ§ P ) est dans H", "On a E tel que [x := E] P = R"
  TYPE; // Stub.

symbol NRM18 [x y : El idt] [H : El (list prd)] [P Q R E : El prd] :
  // Side conditions: "âˆ€ x Â· Â¬ ( VRAI âˆ§ Â¬ P ) est dans H", "On a E tel que [x := E] (P) = R"
  TYPE; // Stub.

symbol NRM19 [x : El idt] [H : El (list prd)] [P Q R E : El prd] :
  // Side conditions: "P est dans H", "On a E tel que [x := E] R = P"
  TYPE; // Stub.

// These rules involve 'non libre dans' and substitution, similar to ALL5, XST7, etc.
symbol NRM20 [x y : El idt] [H : El (list prd)] [P Q E : El prd] :
  // Side conditions: "x non libre dans E"
  TYPE; // Stub.

symbol NRM21 [x y : El idt] [H : El (list prd)] [P Q E : El prd] :
  // Side conditions: "x non libre dans E"
  TYPE; // Stub.

symbol NRM22 [x : El idt] [H : El (list prd)] [P Q E : El prd] :
  // Side conditions: "x non libre dans E"
  TYPE; // Stub.

symbol NRM23 [x : El idt] [H : El (list prd)] [P Q E : El prd] :
  // Side conditions: "x non libre dans E"
  TYPE; // Stub.

symbol NRM24 [x : El idt] [H : El (list prd)] [P Q : El prd] :
  // Side condition: "P n'est pas de la forme A âˆ§ B"
  TYPE; // Stub.

symbol NRM25 [x : El idt] [H : El (list prd)] [P : El prd] :
  // Side condition: "x non libre dans P"
  âœ“ (H âŸ P) â†’
  âœ“ (H âŸ âˆ€ (? x) P); // Forall2 (x) corresponds to âˆ€ x
  // Assuming 'forall2' is also syntactic sugar for universal quantification.

symbol NRM26 [x y : El idt] [H : El (list prd)] [P : El prd] :
  // Side condition: "y non libre dans P"
  âœ“ (H âŸ âˆ€ (x âˆ· nil) P) â†’ // forall2 (x, . . .) Â· P
  âœ“ (H âŸ âˆ€ (x âˆ· y âˆ· nil) P); // forall2 (x, y, . . .) Â· P
  // This rule appears to be for adding universally quantified variables that are not free in P.
  //TYPE; // Stub for more general list of variables.

// These normalization rules involve arithmetic inequalities, variable replacement,
// and a "solver" function, which are beyond the scope of current primitives.
symbol NRM27 [x1 xi xn : El idt] [H : El (list prd)] [P Q R : El prd] :
  // Side conditions: "(xi â‰¤ 0) est dans (P âˆ§ . . . âˆ§ Q)", " (âˆ’xi â‰¤ 0) est dans (P âˆ§ . . . âˆ§ Q)", "On a R tel que [xi := 0](P âˆ§ . . . âˆ§ Q) = R"
  TYPE; // Stub.

symbol NRM28 [x : El idt] [H : El (list prd)] [P Q R S : El prd] :
  // Side conditions: "(x â‰¤ 0) est dans (P âˆ§ . . . âˆ§ Q)", " (âˆ’x â‰¤ 0) est dans (P âˆ§ . . . âˆ§ Q)", "On a S tel que [x := 0](P âˆ§ . . . âˆ§ Q) = S"
  TYPE; // Stub.

symbol NRM29 [a b xi : El exp] [x1 xi_minus_1 xi_plus_1 xn : El idt] [H : El (list prd)] [P Q R S : El prd] :
  // Side conditions: "(a + xi â‰¤ 0) est dans (P âˆ§ . . . âˆ§ Q)", "(b âˆ’ xi â‰¤ 0) est dans (P âˆ§ . . . âˆ§ Q)", "solveur(a + b) = 0", "On a S tel que [xi := b](P âˆ§ . . . âˆ§ Q) = S"
  TYPE; // Stub.

symbol NRM29_1 [a b xi : El exp] [x1 xi_minus_1 xi_plus_1 xn : El idt] [H : El (list prd)] [P Q R S : El prd] :
  // Side conditions: "(xi + a â‰¤ 0) est dans (P âˆ§ . . . âˆ§ Q)", " (âˆ’xi + b â‰¤ 0) est dans (P âˆ§ . . . âˆ§ Q)", "solveur(a + b) = 0", "On a S tel que [xi := b](P âˆ§ . . . âˆ§ Q) = S"
  TYPE; // Stub.

symbol NRM30 [a b x : El exp] [H : El (list prd)] [P Q R S : El prd] :
  // Side conditions: "(a + x â‰¤ 0) est dans (P âˆ§ . . . âˆ§ Q)", "(b âˆ’ x â‰¤ 0) est dans (P âˆ§ . . . âˆ§ Q)", "solveur(a + b) = 0", "On a S tel que [x := b](P âˆ§ . . . âˆ§ Q) = S"
  TYPE; // Stub.

symbol NRM30_1 [a b x : El exp] [H : El (list prd)] [P Q R S : El prd] :
  // Side conditions: "(x + a â‰¤ 0) est dans (P âˆ§ . . . âˆ§ Q)", " (âˆ’x + b â‰¤ 0) est dans (P âˆ§ . . . âˆ§ Q)", "solveur(a + b) = 0", "On a S tel que [x := b](P âˆ§ . . . âˆ§ Q) = S"
  TYPE; // Stub.

// #################
// 5.13. RÃ¨gles sur les Ã©galitÃ©s (Equality Rules)
// #################
notation = infix right 4;
symbol EVR1 [H : El (list prd)] [E : El exp] [P : El prd] :
  âœ“ (H âŸ Â¬ (E = E) â‡’ P);

symbol EVR11 [n m : Set] [H : El (list prd)] [P : El prd] : // n, m are natural numbers based on "n âˆˆ N, m âˆˆ N"
  // Side conditions: "n âˆˆ N", "m âˆˆ N", "n â‰  m"
  TYPE; // Stub for numerical comparison.

symbol EVR2 [H : El (list prd)] [E : El exp] :
  âœ“ (H âŸ FALSE) â†’
  âœ“ (H âŸ Â¬ (E = E));

symbol EVR3 [H : El (list prd)] [E : El exp] [P : El prd] :
  âœ“ (H âŸ P) â†’
  âœ“ (H âŸ (E = E) â‡’ P);

symbol EVR4 [H : El (list prd)] [E : El exp] :
  âœ“ (H âŸ (E = E));

symbol EAXM1 [H : El (list prd)] [E F : El exp] [P : El prd] :
  Prf (elem (Â¬ (F = E)) H) â†’
  âœ“ (H âŸ (E = F) â‡’ P);

symbol EAXM2 [H : El (list prd)] [E F : El exp] [P : El prd] :
  Prf (elem (F = E) H) â†’
  âœ“ (H âŸ Â¬ (E = F) â‡’ P);

symbol EAXM31 [H : El (list prd)] [E F : El exp] :
  Prf (elem (F = E) H) â†’
  âœ“ (H âŸ (E = F));

symbol EAXM32 [H : El (list prd)] [E F : El exp] :
  Prf (elem (Â¬ (F = E)) H) â†’
  âœ“ (H âŸ Â¬ (E = F));

// These rules relate to "P" (a predicate) and are named EIMP.
symbol EIMP51 [H : El (list prd)] [E F : El exp] [P : El prd] :
  Prf (elem (Â¬ (F = E)) H) â†’
  âœ“ (H âŸ P) â†’
  âœ“ (H âŸ Â¬ (E = F) â‡’ P);

symbol EIMP52 [H : El (list prd)] [E F : El exp] [P : El prd] :
  Prf (elem (F = E) H) â†’
  âœ“ (H âŸ P) â†’
  âœ“ (H âŸ (E = F) â‡’ P);

// These rules deal with equality of tuples/records, which implies some structured data types.
symbol EQC1 [H : El (list prd)] [a b c d : El exp] [P : El prd] : TYPE;
  //âœ“ (H âŸ (Â¬ (a = c) âˆ¨ Â¬ (b = d)) â‡’ P) â†’
  //âœ“ (H âŸ Â¬ ((a â¨¾ b) = (c â¨¾ d)) â‡’ P); // Using 'â¨¾' for tuple construction, consistent with vrb.
  // Assuming (a,b) is a tuple.

symbol EQC2 [H : El (list prd)] [a b c d : El exp] [P : El prd] : TYPE;
  //âœ“ (H âŸ (a = c) âˆ§ (b = d) â‡’ P) â†’
  //âœ“ (H âŸ ((a â¨¾ b) = (c â¨¾ d)) â‡’ P);

// These rules relate to a specific "eql set" predicate, which suggests set equality.
symbol EQS1 [H : El (list prd)] [E F : El exp] [R : El prd] : TYPE;
  //âœ“ (H âŸ (E = F) â‡’ R) â†’
  //âœ“ (H âŸ (eql_set E F) â‡’ R); // Assuming eql_set is a predicate.

symbol EQS2 [H : El (list prd)] [E F : El exp] [R : El prd] : TYPE;
  //âœ“ (H âŸ FALSE â‡’ R) â†’
  //âœ“ (H âŸ Â¬ (eql_set E F) â‡’ R);

// These rules involve complex variable substitution and reduction to a simple equality.
symbol EAXM91 [x : El idt] [H : El (list prd)] [p q a b Q : El prd] : // p,q here are predicates (prds), not expressions (exp) for the equals comparison?
  // Side conditions: "âˆ€ x Â· Â¬ ( VRAI âˆ§ p = q ) est dans H", "On a E tel que [x := E](q = p) se rÃ©duise Ã  (a = b)"
  TYPE; // Stub.

symbol EAXM92 [x : El idt] [H : El (list prd)] [p q a b Q : El prd] :
  // Side conditions: "âˆ€ x Â· Â¬ ( VRAI âˆ§ Â¬ (p = q) ) est dans H", "On a E tel que [x := E] (q = p) se rÃ©duise Ã  (a = b)"
  TYPE; // Stub.

// These rules relate to substitution for variables.
symbol OPR1 [x : El idt] [H : El (list prd)] [P Q E : El prd] : // x is a variable (idt), E is an expression (exp)
  // Side conditions: "x est une variable", "x non libre dans H", "x non libre dans E", "Q est le rÃ©sultat de la substitution [x := E] P"
  TYPE; // Stub.

symbol OPR2 [x : El idt] [H : El (list prd)] [P Q E : El prd] :
  // Side conditions: "x est une variable", "x non libre dans H", "x non libre dans E", "Q est le rÃ©sultat de la substitution [x := E] P"
  TYPE; // Stub.

// These rules involve complex "replacement" (substitution) operations within predicates.
symbol ECTR1 [H : El (list prd)] [E F : El exp] [P Q R : El prd] :
  // Side conditions: "Â¬ Q est dans H", "le remplacement de E par F dans Q donne R", "R est dans H"
  TYPE; // Stub.

symbol ECTR2 [H : El (list prd)] [E F : El exp] [P Q R : El prd] :
  // Side conditions: "Â¬ Q est dans H", "le remplacement de E par F dans Q donne R", "R est dans H"
  TYPE; // Stub.

symbol ECTR3 [H : El (list prd)] [E F : El exp] [P Q R : El prd] :
  // Side conditions: "E = F est dans H", "le remplacement de E par F dans P donne R", "R est dans H"
  TYPE; // Stub.

symbol ECTR4 [H : El (list prd)] [E F : El exp] [P Q R : El prd] :
  // Side conditions: "F = E est dans H", "le remplacement de E par F dans P donne R", "R est dans H"
  TYPE; // Stub.

symbol ECTR5 [H : El (list prd)] [E F : El exp] [P Q R : El prd] :
  // Side conditions: "E = F est dans H", "le remplacement de E par F dans P donne R", "Â¬ R est dans H"
  TYPE; // Stub.

symbol ECTR6 [H : El (list prd)] [E F : El exp] [P Q R : El prd] :
  // Side conditions: "F = E est dans H", "le remplacement de E par F dans P donne R", "Â¬ R est dans H"
  TYPE; // Stub.




// #################
// 5.14. RÃ¨gles sur l'arithmÃ©tique (Arithmetic Rules)
// #################
// These rules involve numeric comparisons, arithmetic operations, and a "solver" function.
// They also involve expressions, which need to be defined as distinct from predicates for comparison operators like '<='


symbol AR1 [H : El (list prd)] [E : El exp] [R : El prd] :
  âœ“ (H âŸ R) â†’
  âœ“ (H âŸ (E â‰¤ E) â‡’ R); // Assuming â‰¤ is a binary operator on expressions producing a predicate.

symbol AR2 [a b : El exp] [H : El (list prd)] [R : El prd] :
  // Side conditions: "a est numÃ©rique", "b est numÃ©rique", "a > b"
  TYPE; // Stub due to numeric specific conditions.

symbol AR3 [a : El exp] [H : El (list prd)] [R : El prd] :
  âœ“ (H âŸ ((ðŸ - a) â‰¤ ðŸŽ) â‡’ R) â†’
  âœ“ (H âŸ Â¬ (a â‰¤ ðŸŽ) â‡’ R);

symbol AR4 [E F : El exp] [H : El (list prd)] [R : El prd] :
  // Side conditions: "F â‰¤ 0 est dans H", "E + F > 0"
  TYPE; // Stub due to side conditions.

// These rules involve 'â‰ª' which likely means strictly less than.
symbol AR5 [a : El exp] [H : El (list prd)] [R : El prd] :
  // Side condition: "a â‰ª 0 est dans H" (a < 0 is in H)
  TYPE; // Stub.

symbol AR6 [a : El exp] [H : El (list prd)] [R : El prd] :
  // Side condition: "âˆ’a â‰ª 0 est dans H" (-a < 0 is in H)
  TYPE; // Stub.

symbol AR7 [a b c : El exp] [H : El (list prd)] [R : El prd] :
  // Side conditions: "c + b â‰ª 0 est dans H", "a + c = 0"
  TYPE; // Stub.

symbol AR8 [a b c : El exp] [H : El (list prd)] [R : El prd] :
  // Side conditions: "a âˆ’ b â‰ª 0 est dans H", "a + c = 0"
  TYPE; // Stub.

symbol AR9 [E F : El exp] [H : El (list prd)] [R : El prd] :
  // Side condition: "solveur(E) = F"
  TYPE; // Stub for external solver.

symbol AR10 [H : El (list prd)] [P R : El prd] :
  âœ“ (H âŸ (solveur P) â‡’ R) â†’
  âœ“ (H âŸ P â‡’ R);

symbol AR11 [x : El exp] [H : El (list prd)] [P : El prd] :
  âœ“ (H âŸ Â¬ (x â‰¤ x) â‡’ P);

symbol AR12 [a b : El exp] [H : El (list prd)] [P : El prd] : TYPE;
  //âœ“ ((a â‰¤ b) âˆ· H âŸ P) â†’ // H,(a â‰¤ b) âŠ¢ P
  //âœ“ (H âŸ ((a â‰ª b) â‡’ P)); // Assuming â‰ª means strictly less than.



// #################
// 5.15. RÃ¨gles sur les boolÃ©ens (Boolean Rules)
// #################
// Assuming TRUE and FALSE are defined as propositions in the system.
// 'v' is likely a variable of boolean type or an an expression that evaluates to boolean.
//symbol BOOL11 [v : El exp] [H : El (list prd)] [P : El prd] :
//  âœ“ (((v = TRUE) âˆ· (Â¬ (v = FALSE)) âˆ· H) âŸ P) â†’
//  âœ“ (H âŸ (v = TRUE) â‡’ P);

//symbol BOOL12 [v : El exp] [H : El (list prd)] [P : El prd] :
//  âœ“ (((v = FALSE) âˆ· (Â¬ (v = TRUE)) âˆ· H) âŸ P) â†’
//  âœ“ (H âŸ (v = FALSE) â‡’ P);

//symbol BOOL21 [v : El exp] [H : El (list prd)] [P : El prd] :
//  âœ“ (H âŸ (v = TRUE) â‡’ P) â†’
//  âœ“ (H âŸ (TRUE = v) â‡’ P);

//symbol BOOL22 [v : El exp] [H : El (list prd)] [P : El prd] :
//  âœ“ (H âŸ (v = FALSE) â‡’ P) â†’
//  âœ“ (H âŸ (FALSE = v) â‡’ P);

//symbol BOOL31 [v : El exp] [H : El (list prd)] [P : El prd] :
//  âœ“ (H âŸ (v = FALSE) â‡’ P) â†’
//  âœ“ (H âŸ Â¬ (v = TRUE) â‡’ P);

//symbol BOOL32 [v : El exp] [H : El (list prd)] [P : El prd] :
//  âœ“ (H âŸ (v = TRUE) â‡’ P) â†’
//  âœ“ (H âŸ Â¬ (v = FALSE) â‡’ P);

//symbol BOOL41 [v : El exp] [H : El (list prd)] [P : El prd] :
//  âœ“ (H âŸ (v = FALSE) â‡’ P) â†’
//  âœ“ (H âŸ Â¬ (TRUE = v) â‡’ P);

//symbol BOOL42 [v : El exp] [H : El (list prd)] [P : El prd] :
//  âœ“ (H âŸ (v = TRUE) â‡’ P) â†’
//  âœ“ (H âŸ Â¬ (FALSE = v) â‡’ P);

//symbol BOOL51 [H : El (list prd)] [P : El prd] :
//  âœ“ (H âŸ (TRUE = FALSE) â‡’ P);

//symbol BOOL52 [H : El (list prd)] [P : El prd] :
//  âœ“ (H âŸ (FALSE = TRUE) â‡’ P);



// manual reconstruction of `01.trace`
//  [AXM1] &
//  [NOT1] &
//  [OR4] &
//  [IMP4] &
//  [AXM4] &
//  [OR4] &
//  [IMP4] &
//  [AND1] &
//   (not(p and q) => not(p) or not(q))
