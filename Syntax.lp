require open Logic.U.Set Logic.U.Prop Logic.U.Arrow;
require open pp2lp.Prelude;

// primitive logical symbols
injective symbol and : El (prd â¤³ prd â¤³ prd);
injective symbol or : El (prd â¤³ prd â¤³ prd);
injective symbol => : El (prd â¤³ prd â¤³ prd);
injective symbol <=> : El (prd â¤³ prd â¤³ prd);
injective symbol not : El (prd â¤³ prd);
injective symbol forall : El (vrb â¤³ prd â¤³ prd);
injective symbol exists : El (vrb â¤³ prd â¤³ prd);
injective symbol = : El (exp â¤³ exp â¤³ prd);
injective symbol != : El (exp â¤³ exp â¤³ prd);
injective symbol â„² : El frm â†’ El prd;

notation and infix left 2;
notation or  infix left 2;
notation =>  infix left 2;
notation <=> infix left 1;
notation not       prefix 3;

// weird quantifiers (?)
symbol â™¢ : El (vrb â¤³ prd â¤³ prd);
symbol â™¡ : El (vrb â¤³ prd â¤³ prd);

// arithmetic
symbol â‰¤ : El (exp â¤³ exp â¤³ prd);
symbol < : El (exp â¤³ exp â¤³ prd);
symbol â‰ª : El (exp â¤³ exp â¤³ prd);
symbol ðŸŽ : El (exp);
symbol ðŸ : El (exp);
symbol â¨ª : El (exp â¤³ exp);
symbol + : El (exp â¤³ exp â¤³ exp);
symbol - : El (exp â¤³ exp â¤³ exp);
symbol â„• : El exp;
symbol âˆˆ : El (exp â¤³ exp â¤³ prd);
symbol solveur [a : Set] : El (a â¤³ a);

notation â‰¤ infix 5;
notation < infix 5;
notation < infix 5;
notation + infix 5;
notation - infix 5;
notation âˆˆ infix 5;

// booleans
symbol TRUE  : El prd;
symbol FALSE : El prd;
