require open Logic.U.Set Logic.U.Prop Logic.U.Arrow;
require open pp2lp.Prelude;

// primitive logical symbols
injective symbol and : El (prd â¤³ prd â¤³ prd);
injective symbol or : El (prd â¤³ prd â¤³ prd);
injective symbol => : El (prd â¤³ prd â¤³ prd);
injective symbol <=> : El (prd â¤³ prd â¤³ prd);
injective symbol not : El (prd â¤³ prd);
injective symbol ! : El ((exp â¤³ prd) â¤³ prd);
injective symbol # : El ((exp â¤³ prd) â¤³ prd);
injective symbol =  : El (exp â¤³ exp â¤³ prd);
injective symbol != : El (exp â¤³ exp â¤³ prd);
injective symbol â„² : El frm â†’ El prd;

notation = infix left 2;
notation and infix left 2;
notation or  infix left 2;
notation =>  infix left 2;
notation <=> infix left 1;
notation not       prefix 3;

notation ! quantifier;
notation # quantifier;

// weird quantifiers (?)
symbol â™¢ : El ((exp â¤³ prd) â¤³ prd);
symbol â™¡ : El ((exp â¤³ prd) â¤³ prd);

notation â™¢ quantifier;
notation â™¡ quantifier;


// arithmetic
symbol â‰¤ : El (exp â¤³ exp â¤³ prd);
symbol < : El (exp â¤³ exp â¤³ prd);
symbol â‰ª : El (exp â¤³ exp â¤³ prd);
symbol ðŸŽ : El (exp);
symbol ðŸ : El (exp);
symbol â¨ª : El (exp â¤³ exp);
symbol + : El (exp â¤³ exp â¤³ exp);
symbol - : El (exp â¤³ exp â¤³ exp);
symbol â„• : El exp;
symbol âˆˆ : El (exp â¤³ exp â¤³ prd);
symbol solveur [a : Set] : El (a â¤³ a);

notation â‰¤ infix 5;
notation < infix 5;
notation < infix 5;
notation + infix 5;
notation - infix 5;
notation âˆˆ infix 5;

// booleans
symbol VRAI  : El prd;
symbol FAUX : El prd;
